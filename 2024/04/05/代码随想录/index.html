<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="数组LCR 075. 数组的相对排序  给定两个数组，arr1 和 arr2，  arr2 中的元素各不相同 arr2 中的每个元素都出现在 arr1 中  对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。   class Solution &#123; public:     vecto">
<meta property="og:type" content="article">
<meta property="og:title" content="代码随想录">
<meta property="og:url" content="http://example.com/2024/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="数组LCR 075. 数组的相对排序  给定两个数组，arr1 和 arr2，  arr2 中的元素各不相同 arr2 中的每个元素都出现在 arr1 中  对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。   class Solution &#123; public:     vecto">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedundefinedimage-20240317193142544.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedundefinedimage-20240317201756160.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240329113429301.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240329134458686.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240329150450158.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240329163723038.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240330111003233.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240330115449732.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240330135011701.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401094203692.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240402123402414.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240402123439614.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240402145125827.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240331095650828.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240317103035653.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240314145536199.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240314152305641.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240314154102307.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240317091802857.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240318212951402.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240319161840788.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240320151731067.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240320161919023.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240324122951233.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240324142857787.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401172527338.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401172629178.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401174200293.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401195255728.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240404104321832.png">
<meta property="og:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240404152555628.png">
<meta property="article:published_time" content="2024-04-05T09:24:57.000Z">
<meta property="article:modified_time" content="2024-04-06T03:39:45.720Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedundefinedimage-20240317193142544.png">

<link rel="canonical" href="http://example.com/2024/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>代码随想录 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/05/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          代码随想录
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-04-05 17:24:57" itemprop="dateCreated datePublished" datetime="2024-04-05T17:24:57+08:00">2024-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-04-06 11:39:45" itemprop="dateModified" datetime="2024-04-06T11:39:45+08:00">2024-04-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="LCR-075-数组的相对排序"><a href="#LCR-075-数组的相对排序" class="headerlink" title="LCR 075. 数组的相对排序"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/0H97ZC/">LCR 075. 数组的相对排序</a></h2><ol>
<li><blockquote>
<p>给定两个数组，<code>arr1</code> 和 <code>arr2</code>，</p>
<ul>
<li><code>arr2</code> 中的元素各不相同</li>
<li><code>arr2</code> 中的每个元素都出现在 <code>arr1</code> 中</li>
</ul>
<p>对 <code>arr1</code> 中的元素进行排序，使 <code>arr1</code> 中项的相对顺序和 <code>arr2</code> 中的相对顺序相同。未在 <code>arr2</code> 中出现过的元素需要按照升序放在 <code>arr1</code> 的末尾。</p>
</blockquote>
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    vector&lt;int&gt; relativeSortArray(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) &#123;
        // 用哈希表记录arr2中每个元素的下标
        unordered_map&lt;int, int&gt; indexMap;
        for (int i = 0; i &lt; arr2.size(); ++i) &#123;
            indexMap[arr2[i]] = i;
        &#125;
        
        // 自定义比较函数，首先按照arr2中的相对顺序排序，然后未在arr2中出现的元素按照升序排列
        auto customSort = [&amp;](int a, int b) &#123;
            if (indexMap.find(a) != indexMap.end() &amp;&amp; indexMap.find(b) != indexMap.end()) &#123;
                return indexMap[a] &lt; indexMap[b]; // 按照arr2中的相对顺序排序
            &#125; else if (indexMap.find(a) != indexMap.end()) &#123;
                return true; // a在arr2中，b不在arr2中，将a放在b之前,就是可以放a
            &#125; else if (indexMap.find(b) != indexMap.end()) &#123;
                return false; // b在arr2中，a不在arr2中，将b放在a之前
            &#125; else &#123;
                return a &lt; b; // 都不在arr2中，按照升序排列
            &#125;
        &#125;;
        
        // 使用自定义比较函数对arr1进行排序
        sort(arr1.begin(), arr1.end(), customSort);
        
        return arr1;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. ```cpp</span><br><span class="line">   vector&lt;int&gt; relativeSortArray(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) &#123;</span><br><span class="line">       vector&lt;int&gt; hash(1001);</span><br><span class="line">       for (int num : arr1) &#123;</span><br><span class="line">           hash[num]++;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       	// 这一步真的巧妙啊！</span><br><span class="line">       int index = 0;</span><br><span class="line">       for (int num : arr2) &#123;</span><br><span class="line">           while (hash[num]-- &gt; 0) &#123;</span><br><span class="line">               arr1[index++] = num;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       // num就是数字，所以是从小到大。</span><br><span class="line">       for (int num = 0; num &lt; hash.size(); num++) &#123;</span><br><span class="line">           while (hash[num]-- &gt; 0) &#123;</span><br><span class="line">               arr1[index++] = num;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       return arr1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="自己写的链表demo"><a href="#自己写的链表demo" class="headerlink" title="自己写的链表demo"></a>自己写的链表demo</h2><ol>
<li><pre><code class="cpp">struct ListNode &#123;
     int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) &#123;&#125;
     ListNode(int x) : val(x), next(nullptr) &#123;&#125;
     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;
 &#125;;

 int main() &#123;
     ListNode* head = new ListNode(4);
    ListNode* p = head;

     for (int i = 0; i &lt; 5; i++) &#123;
         ListNode* q = new ListNode(i + 1);
         p-&gt;next = q;
         p = p-&gt;next;
     &#125;
      p = head;
     while (p) &#123;
         cout &lt;&lt; p-&gt;val &lt;&lt; &quot;--&gt;&quot;;
         p = p-&gt;next;
     &#125;
     return 0;
 &#125;
 
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ![image-20240317200431671](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240317200431671.png) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 给定一个数组vector，还有k，问是否存在两个数的和使得目标和是k，如果是就输出true</span><br><span class="line"></span><br><span class="line">1. ```cpp</span><br><span class="line">   #include &lt;vector&gt;</span><br><span class="line">   #include &lt;unordered_set&gt;</span><br><span class="line">   </span><br><span class="line">   using namespace std;</span><br><span class="line">   </span><br><span class="line">   bool hasSum(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">       unordered_set&lt;int&gt; seen;</span><br><span class="line">       for (int num : nums) &#123;</span><br><span class="line">           int complement = k - num;</span><br><span class="line">           if (seen.count(complement)) &#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           seen.insert(num);</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li></li>
</ol>
<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h2><ol>
<li><p>可以设置一个虚拟节点<code>dummy</code></p>
</li>
<li><p><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedundefinedimage-20240317193142544.png" alt="image-20240317193142544"> </p>
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    ListNode* removeElements(ListNode* head, int val) &#123;
        ListNode* dummy = new ListNode(0);
        dummy-&gt;next = head;
        ListNode* cur = dummy;
        while (cur-&gt;next != NULL) &#123;
            if (cur-&gt;next-&gt;val == val) &#123;
                ListNode* temp = cur-&gt;next;
                cur-&gt;next = cur-&gt;next-&gt;next;
                delete temp;
            &#125; else &#123;
                cur = cur-&gt;next;
            &#125;
        &#125;
        head = dummy-&gt;next;
        delete dummy;
        return head;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [5两两交换链表的结点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)</span><br><span class="line"></span><br><span class="line">1. &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240317195439448.png&quot; alt=&quot;image-20240317195439448&quot; style=&quot;zoom:50%;&quot; /&gt; </span><br><span class="line"></span><br><span class="line">2. 主要步骤</span><br><span class="line"></span><br><span class="line">   ![image-20240317195545629](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240317195545629.png) </span><br><span class="line"></span><br><span class="line">3. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       ListNode* swapPairs(ListNode* head) &#123;</span><br><span class="line">           ListNode* dummy = new ListNode(0);</span><br><span class="line">           dummy-&gt;next = head;</span><br><span class="line">           ListNode* cur = dummy;</span><br><span class="line">           while (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123;</span><br><span class="line">               ListNode* tmp = cur-&gt;next;</span><br><span class="line">               ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line">   </span><br><span class="line">               cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">               cur-&gt;next-&gt;next = tmp;</span><br><span class="line">               cur-&gt;next-&gt;next-&gt;next = tmp1;</span><br><span class="line">               cur = cur-&gt;next-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           return dummy-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><ol>
<li><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedundefinedimage-20240317201756160.png" alt="image-20240317201756160" style="zoom:50%;" /> 
</li>
<li><pre><code class="cpp">ListNode* removeNthFromEnd(ListNode* head, int n) &#123;
    if (head == nullptr || n &lt;= 0) // 边界情况处理
        return nullptr;

    ListNode dummy(0);  // 这里创建的是一个对象
    dummy.next = head;
    ListNode *slow = &amp;dummy;
    ListNode *fast = &amp;dummy;

    // 将 fast 指针向前移动 n+1 步
    for (int i = 0; i &lt; n + 1; ++i) &#123;
        if (fast == nullptr) // 如果链表长度小于 n+1，则直接返回头结点
            return head;
        fast = fast-&gt;next;
    &#125;

    // 同时移动 slow 和 fast 指针，直到 fast 指针到达链表尾部
    while (fast != nullptr) &#123;
        slow = slow-&gt;next;
        fast = fast-&gt;next;
    &#125;

    // 删除倒数第 n 个节点
    ListNode *temp = slow-&gt;next;
    slow-&gt;next = slow-&gt;next-&gt;next;
    delete temp;

    return dummy.next;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 递归方法</span><br><span class="line"></span><br><span class="line">   ```cpp</span><br><span class="line">   #include &lt;iostream&gt;</span><br><span class="line">   </span><br><span class="line">   struct ListNode &#123;</span><br><span class="line">       int val;</span><br><span class="line">       ListNode *next;</span><br><span class="line">       ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   // 辅助函数，用于计算链表长度</span><br><span class="line">   int getLength(ListNode* head) &#123;</span><br><span class="line">       int length = 0;</span><br><span class="line">       while (head != nullptr) &#123;</span><br><span class="line">           ++length;</span><br><span class="line">           head = head-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       return length;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 递归函数，用于删除倒数第 n 个节点</span><br><span class="line">   ListNode* removeNthFromEndRecursive(ListNode* head, int n, int&amp; count) &#123;</span><br><span class="line">       // 边界情况处理，当链表为空或者n为0时，直接返回头结点</span><br><span class="line">       if (head == nullptr || n == 0) &#123;</span><br><span class="line">           return head;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       // 递归到链表末尾，返回nullptr，count表示当前节点是倒数第几个节点</span><br><span class="line">       if (head-&gt;next == nullptr) &#123;</span><br><span class="line">           ++count;</span><br><span class="line">           // 如果当前节点是倒数第n个节点，删除该节点并返回nullptr</span><br><span class="line">           if (count == n) &#123;</span><br><span class="line">               delete head;</span><br><span class="line">               return nullptr;</span><br><span class="line">           &#125;</span><br><span class="line">           return head;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       // 递归调用，删除倒数第n个节点</span><br><span class="line">       head-&gt;next = removeNthFromEndRecursive(head-&gt;next, n, count);</span><br><span class="line">   </span><br><span class="line">       // 每次递归返回前，计数器+1</span><br><span class="line">       ++count;</span><br><span class="line">   </span><br><span class="line">       // 如果当前节点是倒数第n个节点，删除该节点并返回下一个节点</span><br><span class="line">       if (count == n) &#123;</span><br><span class="line">           ListNode* temp = head-&gt;next;</span><br><span class="line">           delete head;</span><br><span class="line">           return temp;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       return head;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   ListNode* removeNthFromEnd(ListNode* head, int n) &#123;</span><br><span class="line">       int count = 0;</span><br><span class="line">       // 调用递归函数</span><br><span class="line">       return removeNthFromEndRecursive(head, n, count);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 辅助函数，用于打印链表</span><br><span class="line">   void printList(ListNode* head) &#123;</span><br><span class="line">       while (head != nullptr) &#123;</span><br><span class="line">           std::cout &lt;&lt; head-&gt;val &lt;&lt; &quot; &quot;;</span><br><span class="line">           head = head-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       std::cout &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   int main() &#123;</span><br><span class="line">       // 创建示例链表：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span><br><span class="line">       ListNode *head = new ListNode(1);</span><br><span class="line">       head-&gt;next = new ListNode(2);</span><br><span class="line">       head-&gt;next-&gt;next = new ListNode(3);</span><br><span class="line">       head-&gt;next-&gt;next-&gt;next = new ListNode(4);</span><br><span class="line">       head-&gt;next-&gt;next-&gt;next-&gt;next = new ListNode(5);</span><br><span class="line">   </span><br><span class="line">       std::cout &lt;&lt; &quot;Original List: &quot;;</span><br><span class="line">       printList(head);</span><br><span class="line">   </span><br><span class="line">       int n = 2; // 要删除的倒数第 n 个节点</span><br><span class="line">       head = removeNthFromEnd(head, n);</span><br><span class="line">   </span><br><span class="line">       std::cout &lt;&lt; &quot;List after removing &quot; &lt;&lt; n &lt;&lt; &quot;th node from end: &quot;;</span><br><span class="line">       printList(head);</span><br><span class="line">   </span><br><span class="line">       // 释放内存</span><br><span class="line">       while (head != nullptr) &#123;</span><br><span class="line">           ListNode *temp = head;</span><br><span class="line">           head = head-&gt;next;</span><br><span class="line">           delete temp;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h2><ol>
<li><p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p>
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    ListNode* deleteDuplicates(ListNode* head) &#123;
        if (head == nullptr || head-&gt;next == nullptr) &#123;
            return head; // 如果链表为空或只有一个节点，则直接返回原链表
        &#125;
        
        ListNode* current = head;
        while (current-&gt;next) &#123;
            if (current-&gt;val == current-&gt;next-&gt;val) &#123;
                ListNode* temp = current-&gt;next;
                current-&gt;next = current-&gt;next-&gt;next; // 跳过重复的节点
                delete temp; // 删除重复的节点
            &#125; else &#123;
                current = current-&gt;next; // 继续遍历链表
            &#125;	
        &#125;
        
        return head;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 自己写的</span><br><span class="line"></span><br><span class="line">   ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">           if (!head || head-&gt;next == nullptr) return head;</span><br><span class="line">           // 现在至少有两个结点了</span><br><span class="line">           ListNode* cur = head;</span><br><span class="line">           while (cur-&gt;next) &#123;</span><br><span class="line">               ListNode* tmp = cur-&gt;next;</span><br><span class="line">               if (cur-&gt;val == tmp-&gt;val) &#123;</span><br><span class="line">                   cur-&gt;next = tmp-&gt;next;</span><br><span class="line">                   delete(tmp);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   cur = cur-&gt;next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return head;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h2><ol>
<li><p>注意比较这一题和上一道题目的异同点，这一题是，把所有的一连串的都给删除了，上一题是还剩下一个。</p>
</li>
<li><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240329113429301.png" alt="image-20240329113429301" style="zoom:50%;" />
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    ListNode* deleteDuplicates(ListNode* head) &#123;
        if (!head || head-&gt;next == nullptr) &#123;
            return head;
        &#125;
        ListNode* dummy = new ListNode(0);
        dummy-&gt;next = head;
        ListNode* cur = dummy;

        while (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123;
            if (cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val) &#123; // 要使用if循环就得在while里面判断空指针。
                int the_val = cur-&gt;next-&gt;val;
                ListNode* p = cur-&gt;next;
                while (p &amp;&amp; p-&gt;val == the_val) &#123;
                    p = p-&gt;next;
                &#125;
                cur-&gt;next = p;
            &#125; else &#123; // 当前节点的后两个值不一样，cur向后移动一个
                cur = cur-&gt;next;
            &#125;
        &#125;
        return dummy-&gt;next;
    &#125;

&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240329113634140.png&quot; alt=&quot;image-20240329113634140&quot; style=&quot;zoom:33%;&quot; /&gt; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)</span><br><span class="line"></span><br><span class="line">1. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   private:</span><br><span class="line">       int num[100010];</span><br><span class="line">   public:</span><br><span class="line">       bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">           // 开一个数组</span><br><span class="line">           if (!head || head-&gt;next == nullptr) &#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           ListNode* cur = head;</span><br><span class="line">           int index = 0;</span><br><span class="line">           while (cur) &#123;</span><br><span class="line">               num[index++] = cur-&gt;val;</span><br><span class="line">               cur = cur-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">               if (num[i] != num[index - 1 - i]) return false;</span><br><span class="line">           &#125;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></h2><ul>
<li><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240329134458686.png" alt="image-20240329134458686" style="zoom:50%;" />
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;
        if (!headA || !headB) return nullptr;

        // 计算链表长度和尾节点
        int lenA = getLength(headA);
        int lenB = getLength(headB);

        ListNode *tailA = getTail(headA);
        ListNode *tailB = getTail(headB);

        // 如果尾节点不同，说明不相交
        if (tailA != tailB) return nullptr;

        ListNode *curA = headA;
        ListNode *curB = headB;

        // 长链表先移动差值个节点
        if (lenA &gt; lenB) &#123;
            for (int i = 0; i &lt; lenA - lenB; ++i) &#123;
                curA = curA-&gt;next;
            &#125;
        &#125; else &#123;
            for (int i = 0; i &lt; lenB - lenA; ++i) &#123;
                curB = curB-&gt;next;
            &#125;
        &#125;

        // 同时遍历两个链表，找到第一个相交节点
        while (curA != curB) &#123;
            curA = curA-&gt;next;
            curB = curB-&gt;next;
        &#125;

        return curA; // 返回相交节点或nullptr
    &#125;

    // 获取链表长度
    int getLength(ListNode *head) &#123;
        int len = 0;
        while (head) &#123;
            len++;
            head = head-&gt;next;
        &#125;
        return len;
    &#125;

    // 获取链表尾节点
    ListNode *getTail(ListNode *head) &#123;
        if (!head) return nullptr;
        while (head-&gt;next) &#123;
            head = head-&gt;next;
        &#125;
        return head;
    &#125;
&#125;;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## [面试题 02.01. 移除重复节点](https://leetcode.cn/problems/remove-duplicate-node-lcci/)</span><br><span class="line"></span><br><span class="line">1. &gt;编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</span><br><span class="line">   &gt;</span><br><span class="line">   &gt;**示例1:**</span><br><span class="line">   &gt;</span><br></pre></td></tr></table></figure>
 &gt; 输入：[1, 2, 3, 3, 2, 1]
 &gt; 输出：[1, 2, 3]
 &gt;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">  #include &lt;unordered_set&gt;</span><br><span class="line">  </span><br><span class="line">  class Solution &#123;</span><br><span class="line">  public:</span><br><span class="line">      ListNode* removeDuplicates(ListNode* head) &#123;</span><br><span class="line">          if (!head || !head-&gt;next) &#123;</span><br><span class="line">              return head;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          std::unordered_set&lt;int&gt; seen;</span><br><span class="line">          seen.insert(head-&gt;val);</span><br><span class="line">          ListNode* prev = head;</span><br><span class="line">          ListNode* curr = head-&gt;next;</span><br><span class="line">          </span><br><span class="line">          while (curr) &#123;</span><br><span class="line">              if (seen.count(curr-&gt;val)) &#123;</span><br><span class="line">                  // 如果当前节点值已经存在于哈希集合中，说明是重复节点，删除当前节点</span><br><span class="line">                  prev-&gt;next = curr-&gt;next;</span><br><span class="line">                  delete curr;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  // 否则，将当前节点值加入哈希集合中，并更新prev指针</span><br><span class="line">                  seen.insert(curr-&gt;val);</span><br><span class="line">                  prev = curr;</span><br><span class="line">              &#125;</span><br><span class="line">              curr = prev-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          return head;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>3. </p>
<h2 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h2><ol>
<li><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240329150450158.png" alt="image-20240329150450158" style="zoom:50%;" />
</li>
<li><pre><code class="cpp">class Solution &#123;
private:
    int getLen(ListNode* head) &#123;
        int len = 0;
        ListNode* p = head;
        while (p) &#123;
            len++;
            p = p-&gt;next;
        &#125;
        return len;
    &#125;
public:
    ListNode* middleNode(ListNode* head) &#123;
        if (!head || !head-&gt;next) return head;
        int len = getLen(head);
        len /= 2;
        
        ListNode* p = head;
        while (len--) &#123;
            p = p-&gt;next;
        &#125;
        return p;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [面试题 02.03. 删除中间节点](https://leetcode.cn/problems/delete-middle-node-lcci/)</span><br><span class="line"></span><br><span class="line">1. 若链表中的某个节点，既不是链表头节点，也不是链表尾节点，则称其为该链表的「中间节点」。</span><br><span class="line"></span><br><span class="line">   假定已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。</span><br><span class="line"></span><br><span class="line">   例如，传入节点 `c`（位于单向链表 `a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f` 中），将其删除后，剩余链表为 `a-&gt;b-&gt;d-&gt;e-&gt;f`</span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       // 后面一个结点的值替换为前一个，然后删除下一个节点。</span><br><span class="line">       void deleteNode(ListNode* node) &#123;</span><br><span class="line">           if (!node || !node-&gt;next) return; // 题上说了不是最后一个结点</span><br><span class="line">   </span><br><span class="line">           ListNode* nextNode = node-&gt;next;</span><br><span class="line">           node-&gt;val = nextNode-&gt;val;</span><br><span class="line">           node-&gt;next = nextNode-&gt;next;</span><br><span class="line">   </span><br><span class="line">           delete nextNode;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="LCR-024-反转链表"><a href="#LCR-024-反转链表" class="headerlink" title="LCR 024. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/UHnkqh/">LCR 024. 反转链表</a></h2><ol>
<li><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240329163723038.png" alt="image-20240329163723038" style="zoom:50%;" />
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        ListNode* pre = nullptr;
        ListNode* cur = head;

        while (cur) &#123;
            ListNode* nextList = cur-&gt;next;
            cur-&gt;next = pre;
            pre = cur;
            cur = nextList;
        &#125;
        return pre; 
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 最后pre不是空的，cur是空的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [LCR 142. 训练计划 IV](https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)</span><br><span class="line"></span><br><span class="line">1. &gt;给定两个以 **有序链表** 形式记录的训练计划 `l1`、`l2`，分别记录了两套核心肌群训练项目编号，请合并这两个训练计划，按训练项目编号 **升序** 记录于链表并返回。</span><br><span class="line">   &gt;</span><br><span class="line">   &gt;**注意**：新链表是通过拼接给定的两个链表的所有节点组成的。</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; </span><br><span class="line">   &gt;</span><br><span class="line">   &gt;**示例 1：**</span><br><span class="line">   &gt;</span><br><span class="line">   &gt;```txt</span><br><span class="line">   &gt;输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">   &gt;输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="cpp">    ListNode* dummy = new ListNode(0);
    ListNode* current = dummy;

    while (l1 != nullptr &amp;&amp; l2 != nullptr) &#123;
        if (l1-&gt;val &lt; l2-&gt;val) &#123;
            current-&gt;next = l1;
            l1 = l1-&gt;next;
        &#125; else &#123;
            current-&gt;next = l2;
            l2 = l2-&gt;next;
        &#125;
        current = current-&gt;next;
    &#125;

    current-&gt;next = (l1 != nullptr) ? l1 : l2;

    return dummy-&gt;next;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## [1171. 从链表中删去总和值为零的连续节点](https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list/)</span><br><span class="line"></span><br><span class="line">1. 看了一个视频，不太懂啊</span><br><span class="line"></span><br><span class="line">2. 懂了，就是一个连续的区间，由于哈希表的一个key只可以对应一个value，所以重复出现的会被删除。出现了，就说明是说。原本的sum值都有（你想一想，都是正数连续的递增的，但是现在由于有负数，导致一些抵消了，value消失了）所以，第二次循环的时候，就直接跳过这一段，直接指向下一段的结点。</span><br><span class="line"></span><br><span class="line">3. ![image-20240330101548937](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240330101548937.png)</span><br><span class="line"></span><br><span class="line">4. ```cpp</span><br><span class="line">   /**</span><br><span class="line">    * Definition for singly-linked list.</span><br><span class="line">    * struct ListNode &#123;</span><br><span class="line">    *     int val;</span><br><span class="line">    *     ListNode *next;</span><br><span class="line">    *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">    *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">    *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">    * &#125;;</span><br><span class="line">    */</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       ListNode* removeZeroSumSublists(ListNode* head) &#123;</span><br><span class="line">       // 创建虚拟头节点</span><br><span class="line">       ListNode* dummy = new ListNode(0);</span><br><span class="line">       dummy-&gt;next = head;</span><br><span class="line">       </span><br><span class="line">       // 创建哈希表，存储前缀和及对应节点的指针</span><br><span class="line">       std::unordered_map&lt;int, ListNode*&gt; prefixSumMap;</span><br><span class="line">       int sum = 0;</span><br><span class="line">       </span><br><span class="line">       // 计算前缀和并存储到哈希表中</span><br><span class="line">       for (ListNode* p = dummy; p != nullptr; p = p-&gt;next) &#123;</span><br><span class="line">           sum += p-&gt;val;</span><br><span class="line">           prefixSumMap[sum] = p;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       sum = 0;</span><br><span class="line">       // 再次遍历链表，根据前缀和找到对应的节点并删除中间节点</span><br><span class="line">       for (ListNode* p = dummy; p != nullptr; p = p-&gt;next) &#123;</span><br><span class="line">           sum += p-&gt;val;</span><br><span class="line">           // 也可以写成</span><br><span class="line">           //if (mapp.count(sum))</span><br><span class="line">           if (prefixSumMap.find(sum) != prefixSumMap.end()) &#123;</span><br><span class="line">               // 如果前缀和存在，则将当前节点的 next 指针指向哈希表中对应前缀和的节点的下一个节点</span><br><span class="line">               p-&gt;next = prefixSumMap[sum]-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       return dummy-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    ListNode* removeZeroSumSublists(ListNode* head) &#123;
        ListNode* dummy = new ListNode(0);
        dummy-&gt;next = head;

        unordered_map&lt;int, ListNode*&gt; mapp;
        int sum = 0;
        ListNode* p = dummy;
        while (p) &#123;
            sum += p-&gt;val;
            mapp[sum] = p;
            p = p-&gt;next;
        &#125;
        // 还得再遍历一次
        sum = 0;
        p = dummy;
        while (p) &#123;
            sum += p-&gt;val;
            if (mapp.count(sum)) &#123;
                p-&gt;next = mapp[sum]-&gt;next;
            &#125;
            p = p-&gt;next;
        &#125;
        return dummy-&gt;next;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##  [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)</span><br><span class="line"></span><br><span class="line">1. &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240330100616004.png&quot; alt=&quot;image-20240330100616004&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">       ListNode* dummy = new ListNode(0); // 创建虚拟头节点</span><br><span class="line">       ListNode* p = dummy;</span><br><span class="line">       int carry = 0; // 进位</span><br><span class="line">   </span><br><span class="line">       /*</span><br><span class="line">       	这样做进位的都走到后面，就是低位向高位进位</span><br><span class="line">       */</span><br><span class="line">       while (l1 || l2) &#123;</span><br><span class="line">           int num1 = l1 ? l1-&gt;val : 0; // 获取l1当前节点的值，如果l1为空则取0 ,是为了应对，两个链表长度不一样的情况</span><br><span class="line">           int num2 = l2 ? l2-&gt;val : 0; // 获取l2当前节点的值，如果l2为空则取0</span><br><span class="line">   </span><br><span class="line">           int sum = num1 + num2 + carry; // 计算当前位置的和</span><br><span class="line">           carry = sum / 10; // 计算进位</span><br><span class="line">           p-&gt;next = new ListNode(sum % 10); // 创建新节点存储和的个位数</span><br><span class="line">           p = p-&gt;next; // 移动p指针到下一个节点</span><br><span class="line">   </span><br><span class="line">           if (l1) l1 = l1-&gt;next; // 移动l1指针到下一个节点</span><br><span class="line">           if (l2) l2 = l2-&gt;next; // 移动l2指针到下一个节点</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       if (carry &gt; 0) &#123;</span><br><span class="line">           p-&gt;next = new ListNode(carry); // 如果还有进位，需要在末尾添加一个额外节点</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       return dummy-&gt;next; // 返回结果链表的头节点</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><ol>
<li><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240330111003233.png" alt="image-20240330111003233" style="zoom:50%;" />
</li>
<li><p>是位置，不是值</p>
</li>
<li><pre><code class="cpp">class Solution &#123;
private:
    ListNode* reverse(ListNode* head) &#123;
        ListNode* pre = nullptr;
        ListNode* cur = head;
        while (cur) &#123;
            ListNode* nextList = cur-&gt;next;
            cur-&gt;next = pre;
            pre = cur;
            cur = nextList;
        &#125;
        return pre;
    &#125;
    ListNode* getTail(ListNode* head) &#123;
        while (head-&gt;next) &#123;
            head = head-&gt;next;
        &#125;
        return head;
    &#125;
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) &#123;
        ListNode* dummy = new ListNode(-1);
        dummy-&gt;next = head;
        ListNode* pre = dummy;
        // 找到区间的前一个结点
        for (int i = 1; i &lt; left; i++) &#123;
            pre = pre-&gt;next;
        &#125;
        ListNode* cur = pre-&gt;next; // 要排序的区间第一个节点

        ListNode* pre1 = dummy;
        for (int i = 0; i &lt; right; i++) &#123;
            pre1 = pre1-&gt;next;
        &#125;
        ListNode* pre2 = pre1-&gt;next;
        pre1-&gt;next = nullptr;
        
        pre-&gt;next = reverse(cur);
        getTail(pre)-&gt;next = pre2;

        return dummy-&gt;next;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. gpt给的，没仔细看</span><br><span class="line"></span><br><span class="line">   ```cpp</span><br><span class="line">   ListNode* reverseBetween(ListNode* head, int left, int right) &#123;</span><br><span class="line">       if (!head || left == right) &#123;</span><br><span class="line">           return head; // 如果链表为空或left等于right，则直接返回链表头节点</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       ListNode* dummy = new ListNode(0); // 创建虚拟头节点</span><br><span class="line">       dummy-&gt;next = head;</span><br><span class="line">       ListNode* pre = dummy;</span><br><span class="line">   </span><br><span class="line">       // 找到需要反转的区间的前一个节点</span><br><span class="line">       for (int i = 1; i &lt; left; ++i) &#123;</span><br><span class="line">           pre = pre-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       ListNode* cur = pre-&gt;next; // 当前需要反转的节点</span><br><span class="line">       ListNode* next = nullptr;</span><br><span class="line">       </span><br><span class="line">       // 反转区间内的节点</span><br><span class="line">       for (int i = 0; i &lt; right - left; ++i) &#123;</span><br><span class="line">           next = cur-&gt;next; // 先保存下一个节点</span><br><span class="line">           cur-&gt;next = next-&gt;next; // 将当前节点的next指针指向下一个节点的next节点</span><br><span class="line">           next-&gt;next = pre-&gt;next; // 将下一个节点的next指针指向反转区间的前一个节点</span><br><span class="line">           pre-&gt;next = next; // 将反转区间的前一个节点的next指针指向下一个节点</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       return dummy-&gt;next; // 返回反转后的链表头节点</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="37-删除链表中的节点"><a href="#37-删除链表中的节点" class="headerlink" title="37. 删除链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-linked-list/">37. 删除链表中的节点</a></h2><ol>
<li><blockquote>
<p>有一个单链表的 <code>head</code>，我们想删除它其中的一个节点 <code>node</code>。</p>
<p>给你一个需要删除的节点 <code>node</code> 。你将 <strong>无法访问</strong> 第一个节点 <code>head</code>。</p>
<p>链表的所有值都是 <strong>唯一的</strong>，并且保证给定的节点 <code>node</code> 不是链表中的最后一个节点。</p>
<p>删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：</p>
<ul>
<li>给定节点的值不应该存在于链表中。</li>
<li>链表中的节点数应该减少 1。</li>
<li><code>node</code> 前面的所有值顺序相同。</li>
<li><code>node</code> 后面的所有值顺序相同。</li>
</ul>
</blockquote>
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    void deleteNode(ListNode* node) &#123;
        // 后一个的值移动到前一个，然后把下一个节点删除
        ListNode* laterNode = node-&gt;next;
        node-&gt;val = laterNode-&gt;val;
        node-&gt;next = laterNode-&gt;next;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [148. 排序链表](https://leetcode.cn/problems/sort-list/)</span><br><span class="line"></span><br><span class="line">- 我自己的，写408肯定不行</span><br><span class="line"></span><br><span class="line">- ```cpp</span><br><span class="line">  /**</span><br><span class="line">   * Definition for singly-linked list.</span><br><span class="line">   * struct ListNode &#123;</span><br><span class="line">   *     int val;</span><br><span class="line">   *     ListNode *next;</span><br><span class="line">   *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="line">   *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">   *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="line">   * &#125;;</span><br><span class="line">   */</span><br><span class="line">  class Solution &#123;</span><br><span class="line">  private:</span><br><span class="line">      int getLen(ListNode* head) &#123;</span><br><span class="line">          int len = 0;</span><br><span class="line">          while (head) &#123;</span><br><span class="line">              len++;</span><br><span class="line">              head = head-&gt;next;</span><br><span class="line">          &#125;</span><br><span class="line">          return len;</span><br><span class="line">      &#125;</span><br><span class="line">  public:</span><br><span class="line">      ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">          if (!head || !head-&gt;next) return head;</span><br><span class="line">          int len = getLen(head);</span><br><span class="line">          int a[len];</span><br><span class="line">          int index = 0;</span><br><span class="line">          for (ListNode* p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">              a[index++] = p-&gt;val;</span><br><span class="line">          &#125;</span><br><span class="line">          sort(a, a + len);</span><br><span class="line">          index = 0;</span><br><span class="line">          for (ListNode* p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">              p-&gt;val = a[index++];</span><br><span class="line">          &#125;</span><br><span class="line">          return head;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li><p><strong>进阶：</strong>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？<strong>问一下gpt</strong> </p>
</li>
<li><p><strong>归并排序</strong> 是先排序再划分递归，<strong>快速排序</strong> 是先递归再排序</p>
</li>
<li><pre><code class="cpp">// 定义链表节点结构
struct ListNode &#123;
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) &#123;&#125;
&#125;;

// 定义归并排序函数
class Solution &#123;
public:
    ListNode* sortList(ListNode* head) &#123;
        // 如果链表为空或者只有一个节点，则直接返回
        if (!head || !head-&gt;next) return head;

        // 定义两个指针，slow指针每次移动一步，fast指针每次移动两步，找到链表的中间节点
        ListNode *slow = head, *fast = head-&gt;next;
        while (fast &amp;&amp; fast-&gt;next) &#123;
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        &#125;

        // 将链表从中间断开，left指向前半部分链表的头节点，right指向后半部分链表的头节点
        ListNode* right = slow-&gt;next;
        slow-&gt;next = nullptr;

        // 递归对左右两部分链表进行排序
        ListNode* left_sorted = sortList(head);
        ListNode* right_sorted = sortList(right);

        // 合并排序后的左右两部分链表
        return merge(left_sorted, right_sorted);
    &#125;

private:
    // 定义合并两个有序链表的函数
    ListNode* merge(ListNode* l1, ListNode* l2) &#123;
        ListNode* dummy = new ListNode(0); // 创建虚拟头节点
        ListNode* cur = dummy; // 创建当前指针，并指向虚拟头节点

        // 循环比较两个链表节点的值，并按升序将它们合并到结果链表中
        // 只要是其中有一个为空就跳出。
        while (l1 &amp;&amp; l2) &#123;
            if (l1-&gt;val &lt; l2-&gt;val) &#123;
                cur-&gt;next = l1;
                l1 = l1-&gt;next;
            &#125; else &#123;
                cur-&gt;next = l2;
                l2 = l2-&gt;next;
            &#125;
            cur = cur-&gt;next;
        &#125;

        // 将剩余的节点接到结果链表中
        cur-&gt;next = l1 ? l1 : l2;

        return dummy-&gt;next; // 返回合并后的链表头节点
    &#125;
&#125;;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [1669. 合并两个链表](https://leetcode.cn/problems/merge-in-between-linked-lists/)</span><br><span class="line"></span><br><span class="line">1. ![image-20240330113925273](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240330113925273.png)</span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   private:</span><br><span class="line">       ListNode* getNodeByIndex(ListNode* head, int index) &#123;</span><br><span class="line">           // 传进来的是头结点</span><br><span class="line">           for (int i = 0; i &lt; index; i++) &#123;</span><br><span class="line">               head = head-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           return head;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode* getTail(ListNode* head) &#123;</span><br><span class="line">           while (head-&gt;next) &#123;</span><br><span class="line">               head = head-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           return head;</span><br><span class="line">       &#125;</span><br><span class="line">   public:</span><br><span class="line">       ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) &#123;</span><br><span class="line">           ListNode* pre = getNodeByIndex(list1, a - 1);</span><br><span class="line">           ListNode* after = getNodeByIndex(list1, b + 1);</span><br><span class="line">           // 断开</span><br><span class="line">           pre-&gt;next = nullptr;</span><br><span class="line">           pre-&gt;next = list2;</span><br><span class="line">   </span><br><span class="line">           //连接新的</span><br><span class="line">           getTail(list2)-&gt;next = after;</span><br><span class="line">           return list1;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="2181-合并零之间的节点"><a href="#2181-合并零之间的节点" class="headerlink" title="2181. 合并零之间的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-nodes-in-between-zeros/">2181. 合并零之间的节点</a></h2><ol>
<li><p><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240330115449732.png" alt="image-20240330115449732"></p>
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    ListNode* mergeNodes(ListNode* head) &#123;
        ListNode* dummy = new ListNode(0); // 创建虚拟头节点
        ListNode* prev = dummy; // 指针 prev 指向虚拟头节点
        int sum = 0; // 记录累加的值

        // 遍历链表
        while (head) &#123; // 得吧所有节点走完，所以是cur不是cur-&gt;next
            // 如果当前节点的值为 0
            if (head-&gt;val != 0) &#123;
                sum += head-&gt;val; // 将当前节点的值累加到 sum 中
            &#125; else &#123;
                // 如果当前节点的值不为 0，且 sum 不为 0
                if (sum != 0) &#123;
                    prev-&gt;next = new ListNode(sum); // 将累加的值作为新节点的值
                    prev = prev-&gt;next; // 移动 prev 指针到新节点
                    sum = 0; // 将 sum 重置为 0
                &#125;
            &#125;
            head = head-&gt;next; // 移动 head 指针到下一个节点
        &#125;

        return dummy-&gt;next; // 返回虚拟头节点的下一个节点作为合并后的链表头节点
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [86. 分隔链表](https://leetcode.cn/problems/partition-list/)</span><br><span class="line"></span><br><span class="line">1. &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240330131751111.png&quot; alt=&quot;image-20240330131751111&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       ListNode* partition(ListNode* head, int x) &#123;</span><br><span class="line">           if (!head || !head-&gt;next) return head;</span><br><span class="line">           // 首先创建两个链表，再创建两个指针</span><br><span class="line">           ListNode* lowList = new ListNode(-1);</span><br><span class="line">           ListNode* highList = new ListNode(-1);</span><br><span class="line">   </span><br><span class="line">           ListNode* pre = lowList;</span><br><span class="line">           ListNode* later = highList;</span><br><span class="line">   </span><br><span class="line">           // 结果,其实不用创建，直接最后两个连接就可以了</span><br><span class="line">           ListNode* dummy = new ListNode(-1);</span><br><span class="line">           while (head) &#123;</span><br><span class="line">               if (head-&gt;val &lt; x) &#123;</span><br><span class="line">                   pre-&gt;next = new ListNode(head-&gt;val);</span><br><span class="line">                   pre = pre-&gt;next;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   later-&gt;next = new ListNode(head-&gt;val);</span><br><span class="line">                   later = later-&gt;next;</span><br><span class="line">               &#125;</span><br><span class="line">               head = head-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           pre-&gt;next = highList-&gt;next;</span><br><span class="line">           return lowList-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h2><ol>
<li><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240330135011701.png" alt="image-20240330135011701" style="zoom:50%;" />
</li>
<li><pre><code class="cpp">class Solution &#123;
private:
    // 用笨的方法，我先求出来先序序列
    vector&lt;TreeNode*&gt; vec;
    void traversal(TreeNode* root) &#123;
        if (!root) return;
        vec.push_back(root);
        traversal(root-&gt;left);
        traversal(root-&gt;right);
    &#125;
public:
    void flatten(TreeNode* root) &#123;
        if (!root) return;
        traversal(root);
        
        TreeNode* pre = nullptr;
        for (TreeNode* node : vec) &#123;
            if (pre) &#123;
                pre-&gt;left = nullptr;
                pre-&gt;right = node;
            &#125;
            pre = node;
        &#125;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [622. 设计循环队列](https://leetcode.cn/problems/design-circular-queue/)</span><br><span class="line"></span><br><span class="line">1. ```cpp</span><br><span class="line">   class MyCircularQueue &#123;</span><br><span class="line">   private:</span><br><span class="line">       vector&lt;int&gt; data;</span><br><span class="line">       int head;</span><br><span class="line">       int tail;</span><br><span class="line">       int size;</span><br><span class="line">   public:</span><br><span class="line">       MyCircularQueue(int k) &#123;</span><br><span class="line">           data.resize(k);</span><br><span class="line">           head = -1;</span><br><span class="line">           tail = -1;</span><br><span class="line">           size = k;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       bool enQueue(int value) &#123;</span><br><span class="line">           if (isFull()) return false;</span><br><span class="line">           if (isEmpty()) head = 0;</span><br><span class="line">           tail = (tail + 1) % size;</span><br><span class="line">           data[tail] = value;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       bool deQueue() &#123;</span><br><span class="line">           if (isEmpty()) return false;</span><br><span class="line">           //如果是最后一个元素特殊处理</span><br><span class="line">           if (head == tail) &#123;</span><br><span class="line">               head = -1;</span><br><span class="line">               tail = -1;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           head = (head + 1) % size;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       int Front() &#123;</span><br><span class="line">           if (isEmpty()) return -1;</span><br><span class="line">           return data[head];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       int Rear() &#123;</span><br><span class="line">           if (isEmpty()) return -1;</span><br><span class="line">           return data[tail];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       bool isEmpty() &#123;</span><br><span class="line">           if (head == -1) return true;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       bool isFull() &#123;</span><br><span class="line">           if ((tail + 1) % size == head) return true;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="641-设计循环双端队列"><a href="#641-设计循环双端队列" class="headerlink" title="641. 设计循环双端队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-circular-deque/">641. 设计循环双端队列</a></h2><ol>
<li><p><code>rear</code>实际上指的是，最后一个元素的下一个位置，</p>
</li>
<li><p>实际上容量 &#x3D;&#x3D; <code>size + 1</code> 是为了区分，空和满</p>
</li>
<li><pre><code class="cpp">class MyCircularDeque &#123;
private:
    vector&lt;int&gt; data;
    int front;
    int rear;
    int capacity;
public:
    // k是用户实际上希望存储的元素的数量
    MyCircularDeque(int k) &#123;
        data.resize(k + 1);
        front = 0;
        rear = 0;
        capacity = k + 1;
    &#125;
    
    bool insertFront(int value) &#123;
        if (isFull()) return false;
        front = (front - 1 + capacity) % capacity;
        data[front] = value;
        return true;
    &#125;
    
    bool insertLast(int value) &#123;
        if (isFull()) return false;
        data[rear] = value;
        rear = (rear + 1) % capacity;
        return true;
    &#125;
    
    bool deleteFront() &#123;
        if (isEmpty()) return false;
        front = (front + 1) % capacity;
        return true;
    &#125;
    
    bool deleteLast() &#123;
        if (isEmpty()) return false;
        rear = (rear - 1 + capacity) % capacity;
        return true;
    &#125;
    
    int getFront() &#123;
        if (isEmpty()) return -1;
        return data[front];
    &#125;
    
    int getRear() &#123;
        if (isEmpty()) return -1;
        return data[(rear - 1 + capacity) % capacity];
    &#125;
    
    bool isEmpty() &#123;
        return front == rear;
    &#125;
    
    bool isFull() &#123;
        return (rear + 1) % capacity == front;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## [147. 对链表进行插入排序](https://leetcode.cn/problems/insertion-sort-list/)</span><br><span class="line"></span><br><span class="line">1. </span><br><span class="line"></span><br><span class="line">## [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)</span><br><span class="line"></span><br><span class="line">1. &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240331113316207.png&quot; alt=&quot;image-20240331113316207&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       Node* connect(Node* root) &#123;</span><br><span class="line">           vector&lt;vector&lt;Node*&gt;&gt; res;</span><br><span class="line">           if (!root) return NULL;</span><br><span class="line">           queue&lt;Node*&gt; que;</span><br><span class="line">           que.push(root);</span><br><span class="line">   </span><br><span class="line">           while (!que.empty()) &#123;</span><br><span class="line">               int size = que.size();</span><br><span class="line">               vector&lt;Node*&gt; vec;</span><br><span class="line">               for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                   Node* node = que.front();</span><br><span class="line">                   que.pop();</span><br><span class="line">                   vec.push_back(node);</span><br><span class="line">                   if (node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                   if (node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">               &#125;</span><br><span class="line">               res.push_back(vec);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           for (auto&amp; it : res) &#123;</span><br><span class="line">               for (size_t i = 0; i &lt; it.size(); i++) &#123;</span><br><span class="line">                   it[i]-&gt;next = (i &lt; it.size() - 1) ? it[i + 1] : nullptr;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           return root;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><blockquote>
<p>在循环中，您使用了迭代器 <code>x</code> 来遍历 <code>it</code> 中的节点。在内部，您尝试使用 <code>x</code> 的下一个元素 <code>*(x + 1)</code> 来设置当前节点的 <code>next</code> 指针。但是，这种方法会导致问题，因为 <code>x + 1</code> 并不是有效的迭代器。</p>
<p>正确的做法是，使用 <code>it</code> 中的索引来访问节点，并确保索引在合法范围内。以下是修改后的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : res) &#123;</span><br><span class="line">          Node* lastNode = <span class="literal">nullptr</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">auto</span> x = it.<span class="built_in">begin</span>(); x != it.<span class="built_in">end</span>(); x++) &#123;</span><br><span class="line">              (*x)-&gt;next = *(x + <span class="number">1</span>);</span><br><span class="line">              <span class="keyword">if</span> (x-&gt;next == <span class="literal">nullptr</span>) lastNode = x;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//(it.end())-&gt;next = NULL;</span></span><br><span class="line">          lastNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>这样不行！</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h2><ol>
<li><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → L1 → … → Ln - 1 → Ln</span><br></pre></td></tr></table></figure>

<p>请将其重新排列后变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …</span><br></pre></td></tr></table></figure>

<p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    void reorderList(ListNode* head) &#123;
        if (!head || !head-&gt;next) return; // 链表为空或只有一个节点时，无需重排

        // 使用快慢指针找到链表的中间节点
        ListNode *slow = head, *fast = head;
        while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        &#125;

        // 将链表从中间节点处分为两个子链表
        ListNode *secondHead = slow-&gt;next;
        slow-&gt;next = nullptr;

        // 反转第二个子链表
        secondHead = reverseList(secondHead);

        // 将两个子链表合并
        mergeLists(head, secondHead);
    &#125;

private:
    // 反转链表
    ListNode* reverseList(ListNode* head) &#123;
        ListNode *prev = nullptr, *curr = head;
        while (curr) &#123;
            ListNode* nextNode = curr-&gt;next;
            curr-&gt;next = prev;
            prev = curr;
            curr = nextNode;
        &#125;
        return prev;
    &#125;

    // 合并两个链表,交替合并
    void mergeLists(ListNode* l1, ListNode* l2) &#123;
        while (l1 &amp;&amp; l2) &#123;
            ListNode* l1Next = l1-&gt;next;
            ListNode* l2Next = l2-&gt;next;

            l1-&gt;next = l2;
            l2-&gt;next = l1Next;

            l1 = l1Next;
            l2 = l2Next;
        &#125;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [面试题 02.08. 环路检测](https://leetcode.cn/problems/linked-list-cycle-lcci/)</span><br><span class="line"></span><br><span class="line">1. 我的有问题的代码</span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">           // 反正我知道做法，但是证明忘了</span><br><span class="line">           if (!head || !head-&gt;next) return NULL;</span><br><span class="line">   </span><br><span class="line">           ListNode* low = head;</span><br><span class="line">           ListNode* fast = head;</span><br><span class="line">           </span><br><span class="line">           while (low != fast) &#123;</span><br><span class="line">               low = low-&gt;next;</span><br><span class="line">               fast = fast-&gt;next-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           // 相遇了，让慢的回到起点</span><br><span class="line">           low = head;</span><br><span class="line">           while (low != fast) &#123;</span><br><span class="line">               low = low-&gt;next;</span><br><span class="line">               fast = fast-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           return low;</span><br><span class="line">       &#125;   </span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><blockquote>
<p>但是，你的算法中存在一个问题：在检测到快慢指针相遇时，并没有判断快指针 <code>fast</code> 是否已经到达链表末尾（即 <code>fast</code> 的下一个节点是否为空）。如果链表中没有环，那么快指针最终会到达链表的末尾，此时应该返回 <code>NULL</code>，表示链表中不存在环。</p>
</blockquote>
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    ListNode *detectCycle(ListNode *head) &#123;
        // 反正我知道做法，但是证明忘了
        if (!head || !head-&gt;next) return NULL;

        ListNode* slow = head;
        ListNode* fast = head;
        
        while (fast &amp;&amp; fast-&gt;next) &#123;
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
            // 判断快指针是否已经到达链表末尾
            if (slow == fast) &#123;
                // 相遇了，让慢的回到起点
                slow = head;
                while (slow != fast) &#123;
                    slow = slow-&gt;next;
                    fast = fast-&gt;next;
                &#125;
                return slow; // 返回环的入口节点
            &#125;
        &#125;
        return NULL; // 链表中不存在环
    &#125;   
&#125;;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## [2807. 在链表中插入最大公约数](https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/)</span><br><span class="line"></span><br><span class="line">1. ![image-20240401092918361](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401092918361.png)</span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   private:</span><br><span class="line">       int gcd(int a, int b) &#123;</span><br><span class="line">           if (a % b == 0) return b;</span><br><span class="line">           return gcd(b, a % b);</span><br><span class="line">       &#125;</span><br><span class="line">   public:</span><br><span class="line">       ListNode* insertGreatestCommonDivisors(ListNode* head) &#123;</span><br><span class="line">           if (!head || !head-&gt;next) return head;</span><br><span class="line">           ListNode* pre = head;</span><br><span class="line">           ListNode* cur = head-&gt;next;</span><br><span class="line">   </span><br><span class="line">           while (cur) &#123; // 得把所有节点走完，不是cur-&gt;next</span><br><span class="line">               ListNode* newNode = new ListNode(gcd(pre-&gt;val, cur-&gt;val));</span><br><span class="line">               newNode-&gt;next = cur;</span><br><span class="line">               pre-&gt;next = newNode;</span><br><span class="line">               pre = cur;</span><br><span class="line">               cur = cur-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           return head;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="2816-翻倍以链表形式表示的数字"><a href="#2816-翻倍以链表形式表示的数字" class="headerlink" title="2816. 翻倍以链表形式表示的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/double-a-number-represented-as-a-linked-list/">2816. 翻倍以链表形式表示的数字</a></h2><ol start="0">
<li><p><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401094203692.png" alt="image-20240401094203692"> </p>
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    ListNode* doubleIt(ListNode* head) &#123;
        if (!head) return head;
        // stack
        stack&lt;int&gt; st;
        ListNode* p = head;
        while (p) &#123;
            st.push(p-&gt;val);
            p = p-&gt;next;
        &#125;
        // 构造一个新的链表
        // 再创造当前节点的时候，还需要保存进位
        int carry = 0;
        ListNode* dummy = new ListNode(-1);
        ListNode* later = nullptr;
        while (!st.empty()) &#123;
            int sum = carry;
            sum += st.top() * 2 % 10;
            carry = st.top() * 2 / 10;
            st.pop();
            dummy-&gt;next = new ListNode(sum);
            dummy-&gt;next-&gt;next = later;
            later = dummy-&gt;next;
        &#125;
        if (carry &gt; 0) &#123;
            dummy-&gt;next = new ListNode(carry);
            dummy-&gt;next-&gt;next = later;
        &#125;
        return dummy-&gt;next;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [725. 分隔链表](https://leetcode.cn/problems/split-linked-list-in-parts/)</span><br><span class="line"></span><br><span class="line">1. &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401103508220.png&quot; alt=&quot;image-20240401103508220&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   #include &lt;vector&gt;</span><br><span class="line">   #include &lt;cmath&gt; // 包含 ceil() 函数</span><br><span class="line">   using namespace std;</span><br><span class="line">   </span><br><span class="line">   struct ListNode &#123;</span><br><span class="line">       int val;</span><br><span class="line">       ListNode *next;</span><br><span class="line">       ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       vector&lt;ListNode*&gt; splitListToParts(ListNode* head, int k) &#123;</span><br><span class="line">           // 计算链表长度</span><br><span class="line">           int len = 0;</span><br><span class="line">           ListNode* curr = head;</span><br><span class="line">           while (curr) &#123;</span><br><span class="line">               len++;</span><br><span class="line">               curr = curr-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           // 计算每部分的平均长度和余数</span><br><span class="line">           int avg = len / k;</span><br><span class="line">           int extra = len % k;</span><br><span class="line">           </span><br><span class="line">           vector&lt;ListNode*&gt; result;</span><br><span class="line">           curr = head;</span><br><span class="line">           for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">               // 计算当前部分的长度</span><br><span class="line">               int part_len = avg + (i &lt; extra ? 1 : 0);</span><br><span class="line">               if (part_len == 0) &#123;</span><br><span class="line">                   result.push_back(nullptr);</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               // 将当前部分的头结点添加到结果中</span><br><span class="line">               result.push_back(curr);</span><br><span class="line">               </span><br><span class="line">               // 移动指针到当前部分的末尾</span><br><span class="line">               for (int j = 1; j &lt; part_len; j++) &#123;</span><br><span class="line">                   curr = curr-&gt;next;</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               // 断开当前部分与后面部分的连接</span><br><span class="line">               ListNode* temp = curr-&gt;next;</span><br><span class="line">               curr-&gt;next = nullptr;</span><br><span class="line">               curr = temp;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           return result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="cpp">class Solution &#123;
private:
    int getLen(ListNode* head) &#123;
        int len = 0;
        while (head) &#123;
            len++;
            head = head-&gt;next;
        &#125;
        return len;
    &#125;
public:
    vector&lt;ListNode*&gt; splitListToParts(ListNode* head, int k) &#123;
        int len = getLen(head);
        int basis = len / k; // 基础长度
        int m = len % k; // m个basis + 1个
        vector&lt;ListNode*&gt; res;
        ListNode* dummy = new ListNode(-1);
        dummy-&gt;next = head;
        // m == 0特殊处理
        if (m == 0) &#123;
            while (k--) &#123;
                if (head) &#123;
                    res.push_back(head);
                    head = head-&gt;next;
                &#125; else &#123;
                    res.push_back(nullptr);
                &#125;
            &#125;
            return res;
        &#125;
        while (m--) &#123;
            ListNode* cur = dummy;
            for (int i = 0; i &lt; basis + 1; i++) &#123;
                cur = cur-&gt;next;
            &#125;
            ListNode* nextList = cur-&gt;next;
            cur-&gt;next = nullptr;
            res.push_back(dummy-&gt;next);
            dummy-&gt;next = nextList;
        &#125;
        ListNode* cur = dummy;
        while (cur-&gt;next &amp;&amp; cur) &#123;
            for (int i = 0; i &lt; basis; i++) &#123;
                cur = cur-&gt;next;
            &#125;
            ListNode* nextList = cur-&gt;next;
            cur-&gt;next = nullptr;
            res.push_back(dummy-&gt;next);
            dummy-&gt;next = nextList;
        &#125;
        return res;
    &#125;
&#125;; //修改我的程序的bug给出修改意见，并返回最终程序。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. </span><br><span class="line"></span><br><span class="line">## [1019. 链表中的下一个更大节点](https://leetcode.cn/problems/next-greater-node-in-linked-list/)</span><br><span class="line"></span><br><span class="line">1. ![image-20240401111106010](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401111106010.png) </span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   private:</span><br><span class="line">       ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line">           ListNode* pre = nullptr;</span><br><span class="line">           ListNode* cur = head;</span><br><span class="line">           while (cur) &#123;</span><br><span class="line">               ListNode* nextNode = cur-&gt;next;</span><br><span class="line">               cur-&gt;next = pre;</span><br><span class="line">               pre = cur;</span><br><span class="line">               cur = nextNode;</span><br><span class="line">           &#125;</span><br><span class="line">           return pre;</span><br><span class="line">       &#125;</span><br><span class="line">   public:</span><br><span class="line">       vector&lt;int&gt; nextLargerNodes(ListNode* head) &#123;</span><br><span class="line">           if (!head) return vector&lt;int&gt;();</span><br><span class="line">   </span><br><span class="line">           // 反转链表</span><br><span class="line">           ListNode* reversedHead = reverseList(head);</span><br><span class="line">           vector&lt;int&gt; result;</span><br><span class="line">           stack&lt;int&gt; stk;</span><br><span class="line">   </span><br><span class="line">           // 遍历反转后的链表</span><br><span class="line">           while (reversedHead) &#123;</span><br><span class="line">               int val = reversedHead-&gt;val;</span><br><span class="line">   </span><br><span class="line">               // 将比当前节点值小的节点值从栈中弹出</span><br><span class="line">               while (!stk.empty() &amp;&amp; stk.top() &lt;= val) &#123;</span><br><span class="line">                   stk.pop();</span><br><span class="line">               &#125;</span><br><span class="line">   </span><br><span class="line">               // 如果栈为空，说明当前节点是最大值，下一个更大节点值为0</span><br><span class="line">               if (stk.empty()) &#123;</span><br><span class="line">                   result.push_back(0);</span><br><span class="line">               &#125; else &#123; // 否则，下一个更大节点值为栈顶元素</span><br><span class="line">                   result.push_back(stk.top());</span><br><span class="line">               &#125;</span><br><span class="line">   </span><br><span class="line">               // 将当前节点值压入栈中</span><br><span class="line">               stk.push(val);</span><br><span class="line">               // 移动到下一个节点</span><br><span class="line">               reversedHead = reversedHead-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           // 将结果反转得到最终答案</span><br><span class="line">           reverse(result.begin(), result.end());</span><br><span class="line">   </span><br><span class="line">           return result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="2487-从链表中移除节点"><a href="#2487-从链表中移除节点" class="headerlink" title="2487. 从链表中移除节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nodes-from-linked-list/">2487. 从链表中移除节点</a></h2><ol>
<li><p><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240402123402414.png" alt="image-20240402123402414"></p>
</li>
<li><p><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240402123439614.png" alt="image-20240402123439614"> </p>
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    ListNode* reverseList(ListNode* head) &#123;
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr) &#123;
            ListNode* nextNode = curr-&gt;next;
            curr-&gt;next = prev;
            prev = curr;
            curr = nextNode;
        &#125;
        return prev;
    &#125;
    
    ListNode* removeRightGreaterNodes(ListNode* head) &#123;
        if (!head || !head-&gt;next) return head;
        
        head = reverseList(head); // 反转链表以便从左到右比较
        
        ListNode* dummy = new ListNode(0);
        dummy-&gt;next = head;
        
        ListNode* curr = head;
        ListNode* prev = dummy;
        
        int maxVal = curr-&gt;val; // 记录当前最大值
        
        while (curr) &#123;
            if (curr-&gt;val &lt; maxVal) &#123;
                // 移除当前节点
                prev-&gt;next = curr-&gt;next;
                ListNode* temp = curr;
                curr = curr-&gt;next;
                delete temp;
            &#125; else &#123;
                // 更新最大值并移动指针
                maxVal = curr-&gt;val;
                prev = curr;
                curr = curr-&gt;next;
            &#125;
        &#125;
        
        ListNode* result = reverseList(dummy-&gt;next); // 恢复链表原始顺序
        delete dummy;
        
        return result;
    &#125;
&#125;;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [LCR 154. 复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/)</span><br><span class="line"></span><br><span class="line">1. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       Node* copyRandomList(Node* head) &#123;</span><br><span class="line">           unordered_map&lt;Node*, Node*&gt; map;</span><br><span class="line">           Node* t = head;</span><br><span class="line">           Node* dummy = new Node(-10010);</span><br><span class="line">           Node* cur = dummy;</span><br><span class="line">   </span><br><span class="line">           // 第一遍遍历：复制节点并将原节点与复制节点的映射关系存储到哈希表中</span><br><span class="line">           while (head != nullptr) &#123;</span><br><span class="line">               Node* node = new Node(head-&gt;val);</span><br><span class="line">               map[head] = node;</span><br><span class="line">               cur-&gt;next = node;</span><br><span class="line">               cur = cur-&gt;next;</span><br><span class="line">               head = head-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           // 第二遍遍历：复制 random 指针</span><br><span class="line">           cur = dummy-&gt;next;</span><br><span class="line">           head = t;</span><br><span class="line">           while (head != nullptr) &#123;</span><br><span class="line">               cur-&gt;random = map[head-&gt;random]; // 不是map[head]-&gt;random</span><br><span class="line">               cur = cur-&gt;next;</span><br><span class="line">               head = head-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           return dummy-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h2><ul>
<li><blockquote>
<p>问：需要几个哨兵节点？</p>
<p>答：一个就够了。一开始哨兵节点 dummy\textit{dummy}dummy 的 prev\textit{prev}prev 和 next\textit{next}next 都指向 dummy\textit{dummy}dummy。随着节点的插入，dummy\textit{dummy}dummy 的 next\textit{next}next 指向链表的第一个节点（最上面的书），prev\textit{prev}prev 指向链表的最后一个节点（最下面的书）。</p>
<p>问：为什么节点要把 key\textit{key}key 也存下来？</p>
<p>答：在删除链表末尾节点时，也要删除哈希表中的记录，这需要知道末尾节点的 key\textit{key}key。</p>
</blockquote>
</li>
</ul>
<ol>
<li><pre><code class="cpp">class Node &#123;
public:
    int key, value;
    Node *prev, *next;

    Node(int k = 0, int v = 0) : key(k), value(v) &#123;&#125;
&#125;;

class LRUCache &#123;
private:
    int capacity;
    Node *dummy; // 哨兵节点
    unordered_map&lt;int, Node*&gt; key_to_node;

    // 删除一个节点（抽出一本书）
    void remove(Node *x) &#123;
        x-&gt;prev-&gt;next = x-&gt;next;
        x-&gt;next-&gt;prev = x-&gt;prev;
    &#125;

    // 在链表头添加一个节点（把一本书放在最上面）
    void push_front(Node *x) &#123;
        x-&gt;prev = dummy;
        x-&gt;next = dummy-&gt;next;
        x-&gt;prev-&gt;next = x;
        x-&gt;next-&gt;prev = x;
    &#125;

    Node *get_node(int key) &#123;
        auto it = key_to_node.find(key);
        if (it == key_to_node.end()) // 没有这本书
            return nullptr;
        auto node = it-&gt;second; // 有这本书
        remove(node); // 把这本书抽出来
        push_front(node); // 放在最上面
        return node;
    &#125;

public:
    LRUCache(int capacity) : capacity(capacity), dummy(new Node()) &#123;
        dummy-&gt;prev = dummy;	
        dummy-&gt;next = dummy;
    &#125;

    int get(int key) &#123;
        auto node = get_node(key);
        return node ? node-&gt;value : -1;
    &#125;

    void put(int key, int value) &#123;
        auto node = get_node(key);
        if (node) &#123; // 有这本书
            node-&gt;value = value; // 更新 value
            return;
        &#125;
        key_to_node[key] = node = new Node(key, value); // 新书
        push_front(node); // 放在最上面
        if (key_to_node.size() &gt; capacity) &#123; // 书太多了
            auto back_node = dummy-&gt;prev;
            key_to_node.erase(back_node-&gt;key);
            remove(back_node); // 去掉最后一本书
            delete back_node; // 释放内存
        &#125;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [61. 旋转链表](https://leetcode.cn/problems/rotate-list/)</span><br><span class="line"></span><br><span class="line">1. ![image-20240402145101214](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240402145101214.png)</span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   private:</span><br><span class="line">       int getLen(ListNode* head) &#123;</span><br><span class="line">           ListNode* cur = head;</span><br><span class="line">           int len = 0;</span><br><span class="line">           while (cur) &#123;</span><br><span class="line">               len++;</span><br><span class="line">               cur = cur-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           return len;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode* getTail(ListNode* head) &#123;</span><br><span class="line">           while (head-&gt;next) &#123;</span><br><span class="line">               head = head-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           return head;</span><br><span class="line">       &#125;</span><br><span class="line">   public:</span><br><span class="line">       ListNode* rotateRight(ListNode* head, int k) &#123;</span><br><span class="line">           if (!head || !head-&gt;next) return head;</span><br><span class="line">           int len = getLen(head);</span><br><span class="line">           if (k % len == 0) return head;</span><br><span class="line">   </span><br><span class="line">           k = k % len;</span><br><span class="line">           ListNode* dummy = new ListNode(-1);</span><br><span class="line">           // 找到前一个节点</span><br><span class="line">           ListNode* pre = head;</span><br><span class="line">           for (int i = 0; i &lt; len - k - 1; i++) &#123;</span><br><span class="line">               pre = pre-&gt;next;</span><br><span class="line">           &#125;</span><br><span class="line">           ListNode* cur = pre-&gt;next;</span><br><span class="line">           pre-&gt;next = nullptr;</span><br><span class="line">           dummy-&gt;next = cur;</span><br><span class="line">           getTail(dummy)-&gt;next = head;</span><br><span class="line">           return dummy-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240402145125827.png" alt="image-20240402145125827"></p>
</li>
</ol>
<h2 id="2058-找出临界点之间的最小和最大距离"><a href="#2058-找出临界点之间的最小和最大距离" class="headerlink" title="2058. 找出临界点之间的最小和最大距离"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/">2058. 找出临界点之间的最小和最大距离</a></h2><ol>
<li><pre><code class="cpp">class Solution &#123;
public:
    vector&lt;int&gt; nodesBetweenCriticalPoints(ListNode* head) &#123;
        vector&lt;int&gt; vec;
        ListNode* cur = head;
        while (cur) &#123;
            vec.push_back(cur-&gt;val);
            cur = cur-&gt;next;
        &#125;
        int len = vec.size();
        vector&lt;int&gt; bucket;
        for (int i = 1; i &lt; len - 1; i++) &#123;
            if (vec[i] &gt; vec[i-1] &amp;&amp; vec[i] &gt; vec[i+1]) &#123;
                bucket.push_back(i);
            &#125;
            if (vec[i] &lt; vec[i-1] &amp;&amp; vec[i] &lt; vec[i+1]) &#123;
                bucket.push_back(i);
            &#125;
        &#125;
        if (bucket.size() &lt; 2) &#123;
            return &#123;-1, -1&#125;;
        &#125;
        sort(bucket.begin(), bucket.end());
        int minnD = INT_MAX, maxD = bucket.back() - bucket.front();
            // 不是*(bucket.end()) - *(bucket.begin());
        for (int i = 1; i &lt; bucket.size(); i++) &#123;
            minnD = min(minnD, bucket[i] - bucket[i - 1]);
        &#125;
        return &#123;minnD, maxD&#125;;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [1367. 二叉树中的链表](https://leetcode.cn/problems/linked-list-in-binary-tree/)</span><br><span class="line"></span><br><span class="line">1. &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240402152732493.png&quot; alt=&quot;image-20240402152732493&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   // 我的错误代码</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   private:</span><br><span class="line">       bool tag = false;</span><br><span class="line">       // 在中序遍历的过程中，如果发现了节点</span><br><span class="line">       bool dfs(ListNode* head, TreeNode* root) &#123;</span><br><span class="line">           if (head-&gt;val != root-&gt;val) &#123;</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">           if (!head-&gt;next &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           dfs(head-&gt;next, root-&gt;left);</span><br><span class="line">           dfs(head-&gt;next, root-&gt;right);</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       void traversal(ListNode* head, TreeNode* root) &#123;</span><br><span class="line">           if (!root) return;</span><br><span class="line">           traversal(head, root-&gt;left);</span><br><span class="line">           if (head-&gt;val == root-&gt;val) &#123;</span><br><span class="line">               if (dfs(head, root)) tag = true;</span><br><span class="line">           &#125;</span><br><span class="line">           traversal(head, root-&gt;right);</span><br><span class="line">       &#125;</span><br><span class="line">   public:</span><br><span class="line">       bool isSubPath(ListNode* head, TreeNode* root) &#123;</span><br><span class="line">           if (!head) return false;</span><br><span class="line">           traversal(head, root);</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="cpp">class Solution &#123;
private:
    bool tag = false;

    bool dfs(ListNode* head, TreeNode* root) &#123;
        if (!head) return true; // 链表已经遍历完成
        if (!root) return false; // 二叉树遍历结束但链表尚未匹配完成
        if (head-&gt;val != root-&gt;val) return false; // 当前节点值不匹配
        // 递归遍历左右子树，只要有一个子树满足条件即可
        return dfs(head-&gt;next, root-&gt;left) || dfs(head-&gt;next, root-&gt;right);
    &#125;

    void traversal(ListNode* head, TreeNode* root) &#123;
        if (!root || tag) return; // 如果 tag 为 true 或者二叉树已经遍历完毕，直接返回
        traversal(head, root-&gt;left);
        // 检查当前节点是否与链表头节点匹配，如果匹配，则调用 dfs 函数
        if (head-&gt;val == root-&gt;val &amp;&amp; dfs(head, root)) tag = true;
        traversal(head, root-&gt;right);
    &#125;

public:
    bool isSubPath(ListNode* head, TreeNode* root) &#123;
        if (!head || !root) return false; // 空链表或空二叉树
        traversal(head, root);
        return tag;
    &#125;
&#125;;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [2074. 反转偶数长度组的节点](https://leetcode.cn/problems/reverse-nodes-in-even-length-groups/)</span><br><span class="line"></span><br><span class="line">- ![image-20240404101253871](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240404101253871.png)  </span><br><span class="line"></span><br><span class="line">- ```cpp</span><br><span class="line">  #include &lt;vector&gt;</span><br><span class="line">  </span><br><span class="line">  struct ListNode &#123;</span><br><span class="line">      int val;</span><br><span class="line">      ListNode *next;</span><br><span class="line">      ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  class Solution &#123;</span><br><span class="line">  public:</span><br><span class="line">      ListNode* reverseEvenLengthGroups(ListNode* head) &#123;</span><br><span class="line">          std::vector&lt;ListNode*&gt; nodes; // 用于存储链表节点的指针</span><br><span class="line">          int size = 1; // 初始分组大小为1</span><br><span class="line">  </span><br><span class="line">          // 遍历链表</span><br><span class="line">          for (ListNode* node = head; node != nullptr; node = node-&gt;next) &#123;</span><br><span class="line">              nodes.push_back(node); // 将当前节点加入节点数组中</span><br><span class="line">              // 如果已经统计到 size 个节点，或者到达链表末尾</span><br><span class="line">              if (nodes.size() == size || node-&gt;next == nullptr) &#123;</span><br><span class="line">                  // 如果当前分组节点数为偶数</span><br><span class="line">                  if (int n = nodes.size(); n % 2 == 0) &#123;</span><br><span class="line">                      // 对于当前分组中的前半部分节点，与后半部分节点进行值交换</span><br><span class="line">                      for (int i = 0; i &lt; n / 2; ++i) &#123;</span><br><span class="line">                          std::swap(nodes[i]-&gt;val, nodes[n - 1 - i]-&gt;val);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  // 清空节点数组，准备统计下一个分组</span><br><span class="line">                  nodes.clear();</span><br><span class="line">                  size++; // 分组大小加一</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          return head; // 返回头节点</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><ol>
<li><pre><code class="cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    void preorder(TreeNode* root, vector&lt;int&gt; &amp; res) &#123;
        if (root == nullptr) &#123;
            return;
        &#125;
        res.push_back(root-&gt;val);
        preorder(root-&gt;left, res);
        preorder(root-&gt;right, res);
    &#125;

    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;
        vector&lt;int&gt; res;
        preorder(root, res);
        return res;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [328. 奇偶链表](https://leetcode.cn/problems/odd-even-linked-list/)</span><br><span class="line"></span><br><span class="line">1. ![image-20240331102115838](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240331102115838.png)</span><br><span class="line"></span><br><span class="line">2. 积极诶错题意了，连接最后一个奇数结点和第一个偶数节点</span><br><span class="line"></span><br><span class="line">3. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       ListNode* oddEvenList(ListNode* head) &#123;</span><br><span class="line">           // 分开的时候是运用的下标</span><br><span class="line">           if (!head || !head-&gt;next) return head;</span><br><span class="line">           // 看一下第一个为啥</span><br><span class="line">           int tag = 0;</span><br><span class="line">           if (head-&gt;val % 2 == 1) tag = 1;</span><br><span class="line">   </span><br><span class="line">           ListNode* odd = new ListNode(-1);</span><br><span class="line">           ListNode* even = new ListNode(-1);</span><br><span class="line">   </span><br><span class="line">           // 分别针对两个</span><br><span class="line">           ListNode* oddPtr = odd;</span><br><span class="line">           ListNode* evenPtr = even;</span><br><span class="line">   </span><br><span class="line">           ListNode* cur = head;</span><br><span class="line">           int index = 1;</span><br><span class="line">           while (cur) &#123;</span><br><span class="line">               if (index % 2 == 1) &#123;</span><br><span class="line">                   oddPtr-&gt;next = new ListNode(cur-&gt;val);</span><br><span class="line">                   oddPtr = oddPtr-&gt;next;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   evenPtr-&gt;next = new ListNode(cur-&gt;val);</span><br><span class="line">                   evenPtr = evenPtr-&gt;next;</span><br><span class="line">               &#125;</span><br><span class="line">               cur = cur-&gt;next;</span><br><span class="line">               index++;</span><br><span class="line">           &#125;</span><br><span class="line">           //if (tag == 1) &#123;</span><br><span class="line">               oddPtr-&gt;next = even-&gt;next;</span><br><span class="line">               return odd-&gt;next;</span><br><span class="line">           // &#125; else &#123;</span><br><span class="line">           //     evenPtr-&gt;next = odd-&gt;next;</span><br><span class="line">           //     return even-&gt;next;</span><br><span class="line">           // &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers-ii/">445. 两数相加 II</a></h2><ol>
<li><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240331095650828.png" alt="image-20240331095650828" style="zoom:50%;" /> 
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;
        stack&lt;int&gt; s1, s2; // 用栈来存储两个链表的节点值
        while (l1) &#123;
            s1.push(l1-&gt;val);
            l1 = l1-&gt;next;
        &#125;
        while (l2) &#123;
            s2.push(l2-&gt;val);
            l2 = l2-&gt;next;
        &#125;

        ListNode* head = nullptr; // 结果链表的头指针
        int carry = 0; // 进位
        while (!s1.empty() || !s2.empty() || carry != 0) &#123;
            int sum = carry;
            if (!s1.empty()) &#123;
                sum += s1.top();
                s1.pop();
            &#125;
            if (!s2.empty()) &#123;
                sum += s2.top();
                s2.pop();
            &#125;
            carry = sum / 10; // 计算进位
            sum %= 10; // 计算当前位的值

            ListNode* newNode = new ListNode(sum);
            newNode-&gt;next = head;
            head = newNode; // 在头部插入新节点
        &#125;

        return head;
    &#125;
&#125;;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. </span><br><span class="line"></span><br><span class="line">## 后续遍历</span><br><span class="line"></span><br><span class="line">1. ```cpp</span><br><span class="line">   /**</span><br><span class="line">    * Definition for a binary tree node.</span><br><span class="line">    * struct TreeNode &#123;</span><br><span class="line">    *     int val;</span><br><span class="line">    *     TreeNode *left;</span><br><span class="line">    *     TreeNode *right;</span><br><span class="line">    *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">    * &#125;;</span><br><span class="line">    */</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       void postorder(TreeNode* root, vector&lt;int&gt; &amp;res) &#123;</span><br><span class="line">           if (root == nullptr) return;</span><br><span class="line">           postorder(root-&gt;left, res);</span><br><span class="line">           postorder(root-&gt;right, res);</span><br><span class="line">           res.push_back(root-&gt;val);</span><br><span class="line">       &#125;</span><br><span class="line">       vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line">           vector&lt;int&gt; res;</span><br><span class="line">           postorder(root, res);</span><br><span class="line">           return res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">100. 相同的树</a></h2><ol start="0">
<li><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240317103035653.png" alt="image-20240317103035653" style="zoom:50%;" /> 
</li>
<li><pre><code class="cpp">bool isSameTree(TreeNode* p, TreeNode* q) &#123;
    // 如果两个节点都为空，则相同
    if (!p &amp;&amp; !q)
        return true;
    // 如果其中一个节点为空，另一个节点非空，则不相同
    if (!p || !q)
        return false;
    // 如果节点的值不相同，则不相同
    if (p-&gt;val != q-&gt;val)
        return false;
    // 递归检验左右子树
    return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">## [二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)</span><br><span class="line"></span><br><span class="line">1. 非递归版本的**不好理解** ，中午了有点想瞌睡了，看一下递归的拉倒。</span><br><span class="line"></span><br><span class="line">   ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">           queue&lt;TreeNode*&gt; que;</span><br><span class="line">           if (root != NULL) que.push(root);</span><br><span class="line">           vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">           </span><br><span class="line">           while (!que.empty()) &#123;</span><br><span class="line">               int size = que.size();</span><br><span class="line">               vector&lt;int&gt; vec;</span><br><span class="line">               // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span><br><span class="line">               for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                   TreeNode* node = que.front();</span><br><span class="line">                   que.pop();</span><br><span class="line">                   vec.push_back(node-&gt;val);</span><br><span class="line">                   if (node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                   if (node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">               &#125;</span><br><span class="line">               result.push_back(vec);</span><br><span class="line">           &#125;</span><br><span class="line">           return result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h3><ol>
<li><p><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240314145536199.png" alt="image-20240314145536199"> </p>
</li>
<li><pre><code class="cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;
        vector&lt;int&gt; res;
        queue&lt;TreeNode*&gt; que;

        if (root != nullptr) que.push(root);
        while (!que.empty()) &#123;
            int size = que.size();
            for (int i = 0; i &lt; size; i++) &#123;
                TreeNode* node = que.front();
                que.pop();
                if (i == size - 1) res.push_back(node-&gt;val); // 每一层的最后元素放入res
                if (node-&gt;left) que.push(node-&gt;left);
                if (node-&gt;right) que.push(node-&gt;right);
            &#125;
        &#125;
        return res;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)</span><br><span class="line"></span><br><span class="line">1. &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240314150811396.png&quot; alt=&quot;image-20240314150811396&quot; style=&quot;zoom: 50%;&quot; /&gt; </span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   /**</span><br><span class="line">    * Definition for a binary tree node.</span><br><span class="line">    * struct TreeNode &#123;</span><br><span class="line">    *     int val;</span><br><span class="line">    *     TreeNode *left;</span><br><span class="line">    *     TreeNode *right;</span><br><span class="line">    *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">    * &#125;;</span><br><span class="line">    */</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123;</span><br><span class="line">           queue&lt;TreeNode*&gt; que;</span><br><span class="line">           if (root != nullptr) que.push(root);</span><br><span class="line">           vector&lt;double&gt; res;</span><br><span class="line">   </span><br><span class="line">           while (!que.empty()) &#123;</span><br><span class="line">               int size = que.size();</span><br><span class="line">               double sum = 0;</span><br><span class="line">               for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                   TreeNode* node = que.front();</span><br><span class="line">                   que.pop();</span><br><span class="line">                   sum += node-&gt;val;</span><br><span class="line">                   </span><br><span class="line">                   if (node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                   if (node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">               &#125;</span><br><span class="line">               res.push_back(sum / size);</span><br><span class="line">           &#125;</span><br><span class="line">           return res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h3 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></h3><ol>
<li><p><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240314152305641.png" alt="image-20240314152305641"> </p>
</li>
<li><pre><code class="cpp">/*
// Definition for a Node.
class Node &#123;
public:
    int val;
    vector&lt;Node*&gt; children;

    Node() &#123;&#125;

    Node(int _val) &#123;
        val = _val;
    &#125;

    Node(int _val, vector&lt;Node*&gt; _children) &#123;
        val = _val;
        children = _children;
    &#125;
&#125;;
*/

class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;
        vector&lt;vector&lt;int&gt;&gt; res;
        queue&lt;Node*&gt; que;
        if (root != NULL) que.push(root);

        while (!que.empty()) &#123;
            int size = que.size();
            vector&lt;int&gt; vec;

            for (int i = 0; i &lt; size; i++) &#123;
                Node* node = que.front();
                que.pop();
                vec.push_back(node-&gt;val);
                for (int i = 0 ; i &lt; node-&gt;children.size(); i++) &#123;
                    if (node-&gt;children[i] != NULL) &#123;
                        que.push(node-&gt;children[i]);
                    &#125;
                &#125;
            &#125;
            res.push_back(vec);
        &#125;
        return res;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)</span><br><span class="line"></span><br><span class="line">0. &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240317092036652.png&quot; alt=&quot;image-20240317092036652&quot; style=&quot;zoom:50%;&quot; /&gt; </span><br><span class="line"></span><br><span class="line">1. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       vector&lt;int&gt; res;</span><br><span class="line">       // 我先获取 层序遍历的结果，就是数组套数组，然后对于每一个数组，求最大值，时间复杂度就是O（n*n）</span><br><span class="line">       vector&lt;int&gt; largestValues(TreeNode* root) &#123;</span><br><span class="line">           queue&lt;TreeNode*&gt; que;</span><br><span class="line">           if (root != NULL) que.push(root);</span><br><span class="line">   </span><br><span class="line">           while (!que.empty()) &#123;</span><br><span class="line">               int size = que.size();</span><br><span class="line">               vector&lt;int&gt; vec;</span><br><span class="line">               int maxx = INT_MIN;</span><br><span class="line">   </span><br><span class="line">               for (int i = 0 ; i &lt; size; i++) &#123;</span><br><span class="line">                   </span><br><span class="line">                   TreeNode* node = que.front();</span><br><span class="line">                   que.pop();</span><br><span class="line">                   maxx = node-&gt;val &gt; maxx ? node-&gt;val : maxx;</span><br><span class="line">                   // vec.push_back(node-&gt;val);</span><br><span class="line">                   if (node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                   if (node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">               &#125;</span><br><span class="line">               // 现在是一个vec好了，找一下最大值。</span><br><span class="line">               res.push_back(maxx);</span><br><span class="line">           &#125;</span><br><span class="line">           return res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li></li>
</ol>
<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><ol>
<li><p>就是有几层就可以了。</p>
</li>
<li><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240314154102307.png" alt="image-20240314154102307" style="zoom:50%;" />
</li>
<li><pre><code class="cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    int maxDepth(TreeNode* root) &#123;
        queue&lt;TreeNode*&gt; que;
        vector&lt;vector&lt;int&gt;&gt; res;
        if (root != nullptr) que.push(root);

        while (!que.empty()) &#123;
            int size = que.size();
            vector&lt;int&gt; vec;

            for (int i = 0; i &lt; size; i++) &#123;
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node-&gt;val);
                if (node-&gt;left) que.push(node-&gt;left);
                if (node-&gt;right) que.push(node-&gt;right);
            &#125;
            res.push_back(vec);
        &#125;
        return res.size();
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 也可以用**添加一个参数的思想** </span><br><span class="line"></span><br><span class="line">3. ```cpp</span><br><span class="line">   /**</span><br><span class="line">    * Definition for a binary tree node.</span><br><span class="line">    * struct TreeNode &#123;</span><br><span class="line">    *     int val;</span><br><span class="line">    *     TreeNode *left;</span><br><span class="line">    *     TreeNode *right;</span><br><span class="line">    *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">    * &#125;;</span><br><span class="line">    */</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       int result;</span><br><span class="line">       int findMaxdeep(TreeNode* root, int deep) &#123;</span><br><span class="line">           result = deep &gt; result ? deep : result; // 更新result</span><br><span class="line">           if (root-&gt;left == nullptr &amp;&amp; root -&gt;right == nullptr) return result; // 是一个叶子结点。</span><br><span class="line">   </span><br><span class="line">           if (root-&gt; left != nullptr) &#123;</span><br><span class="line">               deep++;</span><br><span class="line">               findMaxdeep(root-&gt;left, deep);</span><br><span class="line">               deep--;</span><br><span class="line">           &#125;</span><br><span class="line">           if (root-&gt;right != nullptr) &#123;</span><br><span class="line">               deep++;</span><br><span class="line">               findMaxdeep(root-&gt;right, deep);</span><br><span class="line">               deep--;</span><br><span class="line">           &#125;</span><br><span class="line">           return result;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       int maxDepth(TreeNode* root) &#123;</span><br><span class="line">           result = 0;</span><br><span class="line">           if (root == nullptr) return result;</span><br><span class="line">           return findMaxdeep(root, 1);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3><ol start="0">
<li><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240317091802857.png" alt="image-20240317091802857" style="zoom: 50%;" /> 
</li>
<li><p>gpt给出的使用递归法，真简单啊！</p>
</li>
<li><p>首先判断是空节点，还是叶子结点。</p>
<ol>
<li><pre><code class="cpp">class Solution &#123;
public:
    int minDepth(TreeNode* root) &#123;
        // 如果树为空，返回深度为0
        if (!root)
            return 0;
        // 如果根节点的左右子树都为空，说明是叶子节点，返回深度为1
        if (!root-&gt;left &amp;&amp; !root-&gt;right)
            return 1;
        // 如果左子树为空，说明只需考虑右子树的深度
        if (!root-&gt;left)
            return 1 + minDepth(root-&gt;right);
        // 如果右子树为空，说明只需考虑左子树的深度
        if (!root-&gt;right)
            return 1 + minDepth(root-&gt;left);
        // 如果左右子树都不为空，则分别求左右子树的深度，取最小值并加上根节点深度1
        return 1 + min(minDepth(root-&gt;left), minDepth(root-&gt;right));
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   2. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)</span><br><span class="line"></span><br><span class="line">1. 中等题啊，十分重要</span><br><span class="line"></span><br><span class="line">2. 关键点在于，得补全为一个**完全二叉树** ，然后计算每一层的最左边和最右边的索引数减一.</span><br><span class="line"></span><br><span class="line">3. 使用**宽搜** ，还有左子树右子树，进行计算。</span><br><span class="line"></span><br><span class="line">4. ```cpp</span><br><span class="line">   /**</span><br><span class="line">    * Definition for a binary tree node.</span><br><span class="line">    * struct TreeNode &#123;</span><br><span class="line">    *     int val;</span><br><span class="line">    *     TreeNode *left;</span><br><span class="line">    *     TreeNode *right;</span><br><span class="line">    *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">    * &#125;;</span><br><span class="line">    */</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       // Leetcode 662. Maximum Width of Binary Tree</span><br><span class="line">       // @爱学习的饲养员</span><br><span class="line">       // BFS</span><br><span class="line">       // N is the size of Tree</span><br><span class="line">       // Time Complexity: O(N)</span><br><span class="line">       // Space Complexity: O(N)</span><br><span class="line">       int widthOfBinaryTree(TreeNode* root) &#123;</span><br><span class="line">           if (root == nullptr)</span><br><span class="line">               return 0;</span><br><span class="line">   </span><br><span class="line">           queue&lt;TreeNode*&gt; q;</span><br><span class="line">           queue&lt;unsigned long long&gt; indexQ; // Use unsigned long long type</span><br><span class="line">           unsigned long long result = 0;</span><br><span class="line">           q.push(root);</span><br><span class="line">           indexQ.push(1);</span><br><span class="line">   </span><br><span class="line">           while (!q.empty()) &#123;</span><br><span class="line">               int levelSize = q.size();</span><br><span class="line">               unsigned long long initialIndex = indexQ.front();</span><br><span class="line">               unsigned long long index = initialIndex;</span><br><span class="line">               while (levelSize &gt; 0) &#123;</span><br><span class="line">                   TreeNode* cur = q.front();</span><br><span class="line">                   q.pop();</span><br><span class="line">                   index = indexQ.front();</span><br><span class="line">                   indexQ.pop();</span><br><span class="line">                   if (cur != nullptr) &#123;</span><br><span class="line">                       if (cur-&gt;left != nullptr) &#123;</span><br><span class="line">                           q.push(cur-&gt;left);</span><br><span class="line">                           indexQ.push(index * 2);</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (cur-&gt;right != nullptr) &#123;</span><br><span class="line">                           q.push(cur-&gt;right);</span><br><span class="line">                           indexQ.push(index * 2 + 1);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   levelSize--;</span><br><span class="line">               &#125;</span><br><span class="line">               unsigned long long width = index - initialIndex + 1;</span><br><span class="line">               result = max(result, width);</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           return result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h2><ol>
<li><pre><code class="cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    TreeNode* invertTree(TreeNode* root) &#123;
        if (root == NULL) return root;
        stack&lt;TreeNode*&gt; st;
        st.push(root);

        while (!st.empty()) &#123;
            TreeNode* node = st.top();
            st.pop();
            swap(node-&gt;left, node-&gt;right); // 就是也不用管它空不空，直接交换就可以了。
            if (node-&gt;right) st.push(node-&gt;right);
            if (node-&gt;left) st.push(node-&gt;left);
        &#125;
        return root;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       bool isSymmetricNodes(TreeNode* leftNode, TreeNode* rightNode) &#123;</span><br><span class="line">           if (!leftNode &amp;&amp; !rightNode) // 两个都是空</span><br><span class="line">               return true;</span><br><span class="line">           if (!leftNode || !rightNode) // 其中一个有，两个都有不行！</span><br><span class="line">               return false;</span><br><span class="line">           return (leftNode-&gt;val == rightNode-&gt;val) &amp;&amp;</span><br><span class="line">                  isSymmetricNodes(leftNode-&gt;left, rightNode-&gt;right) &amp;&amp;</span><br><span class="line">                  isSymmetricNodes(leftNode-&gt;right, rightNode-&gt;left);</span><br><span class="line">   	&#125;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       bool compare(TreeNode* left, TreeNode* right) &#123;  // </span><br><span class="line">           if (left == NULL &amp;&amp; right != NULL) return false;</span><br><span class="line">           else if (left != NULL &amp;&amp; right == NULL) return false;</span><br><span class="line">           else if (left == NULL &amp;&amp; right == NULL) return true;</span><br><span class="line">           else if (left-&gt;val != right-&gt;val) return false;</span><br><span class="line">   </span><br><span class="line">           // 左右子树都不为空，并且值相同。</span><br><span class="line">           bool inside = compare(left-&gt;right, right-&gt;left);</span><br><span class="line">           bool outside = compare(right-&gt;right, left-&gt;left);</span><br><span class="line">           return inside &amp;&amp; outside;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       bool isSymmetric(TreeNode* root) &#123;</span><br><span class="line">           if (root == nullptr ) return true;</span><br><span class="line">           return compare(root-&gt;left, root-&gt;right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="cpp">bool compare(TreeNode* left, TreeNode* right) &#123;
        if (!left &amp;&amp; !right) return true; // 这一句话在前面，两个都是空
        if (!left || !right) return false; 
        
    /*
    if (!left &amp;&amp; !right) return true; 这样就行了
        if (!left || !right) return false;*/
        if (left-&gt;val != right-&gt;val) return false;
        return compare(left-&gt;right, right-&gt;left) &amp;&amp; compare(left-&gt;left, right-&gt;right);
    &#125;
    bool isSymmetric(TreeNode* root) &#123;
        if (!root) return true;
        return compare(root-&gt;left, root-&gt;right);
    &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">3. 上面这样写不行啊！？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [11. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)</span><br><span class="line"></span><br><span class="line">1. ```cpp</span><br><span class="line">   /**</span><br><span class="line">    * Definition for a binary tree node.</span><br><span class="line">    * struct TreeNode &#123;</span><br><span class="line">    *     int val;</span><br><span class="line">    *     TreeNode *left;</span><br><span class="line">    *     TreeNode *right;</span><br><span class="line">    *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">    * &#125;;</span><br><span class="line">    */</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       int countNodes(TreeNode* root) &#123;</span><br><span class="line">           long long ans = 0;</span><br><span class="line">           // vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">           queue&lt;TreeNode*&gt; que;</span><br><span class="line">           if (root == nullptr) return 0;</span><br><span class="line">           que.push(root);</span><br><span class="line">   </span><br><span class="line">           while (!que.empty()) &#123;</span><br><span class="line">               int size = que.size();</span><br><span class="line">               vector&lt;int&gt; vec;</span><br><span class="line">               for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                   TreeNode* node = que.front();</span><br><span class="line">                   que.pop();</span><br><span class="line">                   vec.push_back(node-&gt;val);</span><br><span class="line">                   if (node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                   if (node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">               &#125;</span><br><span class="line">               // res.push_back(vec);</span><br><span class="line">               ans += vec.size();</span><br><span class="line">           &#125;</span><br><span class="line">           return ans;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li></li>
</ol>
<h2 id="12-平衡二叉树"><a href="#12-平衡二叉树" class="headerlink" title="12.平衡二叉树"></a>12.平衡二叉树</h2><ol>
<li><p>求高度要用<strong>后序遍历</strong>，求深度，用先序遍历。</p>
</li>
<li><p>高度是相对于最下面一层，所以要用后序遍历，如果左右子树都符合条件了，然后就可以加上根节点的（+1）</p>
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    int getHeight(TreeNode* root) &#123;
        if (root == nullptr) return 0;
        // 先看两个子树
        int leftHeight = getHeight(root-&gt;left); // 左
        if (leftHeight == -1) return -1;
        int rightHeight = getHeight(root-&gt;right); // 右
        if (rightHeight == -1) return -1;

        int result = 0;
        if (abs(leftHeight - rightHeight) &gt; 1) result = -1; // 中，说明不平衡了。就没必要计算了。
        else &#123;
            result = max(leftHeight, rightHeight) + 1;
        &#125;
        return result;
    &#125;
    bool isBalanced(TreeNode* root) &#123;
        if (getHeight(root) == -1) &#123;
            return false;
        &#125; else &#123;
            return true;
        &#125;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [13. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)</span><br><span class="line"></span><br><span class="line">1. 终止条件，就是收集到叶子结点。</span><br><span class="line"></span><br><span class="line">2. 数组`vector` 转化为 `string` </span><br><span class="line"></span><br><span class="line">3. ```cpp</span><br><span class="line">   // path不是全局最后的那个结果，所以不用引用。</span><br><span class="line">   void binaryTreePathsHelper(TreeNode* root, string path, vector&lt;string&gt;&amp; result) &#123;</span><br><span class="line">       // 如果节点为空，则直接返回</span><br><span class="line">       if (!root)</span><br><span class="line">           return;</span><br><span class="line">   </span><br><span class="line">       // 将当前节点的值添加到路径中</span><br><span class="line">       path += to_string(root-&gt;val);</span><br><span class="line">   </span><br><span class="line">       // 如果当前节点是叶子节点，则将路径加入结果集中</span><br><span class="line">       if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">           result.push_back(path);</span><br><span class="line">           return; // 开始找下一个路径</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       // 继续遍历左右子树</span><br><span class="line">       path += &quot;-&gt;&quot;;</span><br><span class="line">       binaryTreePathsHelper(root-&gt;left, path, result);</span><br><span class="line">       binaryTreePathsHelper(root-&gt;right, path, result);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;</span><br><span class="line">       vector&lt;string&gt; result;</span><br><span class="line">       binaryTreePathsHelper(root, &quot;&quot;, result);</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h2><ol start="0">
<li><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240318212951402.png" alt="image-20240318212951402" style="zoom:50%;" /> 
</li>
<li><pre><code class="cpp">    long long sum = 0;
    bool isLeaf(TreeNode* root) &#123;
        if (root == NULL) return false;
        if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) return true;
        return false;
    &#125;
    int sumOfLeftLeaves(TreeNode* root) &#123;
        if (root == NULL) return 0;
        if (!root-&gt;left &amp;&amp; !root-&gt;right) return 0;
        if (root-&gt;left &amp;&amp; isLeaf(root-&gt;left)) sum += root-&gt;left-&gt;val;
        sumOfLeftLeaves(root-&gt;left);
        sumOfLeftLeaves(root-&gt;right);
        return sum;
    &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## [17. 路径总和](https://leetcode.cn/problems/path-sum/)</span><br><span class="line"></span><br><span class="line">1. &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240319160948462.png&quot; alt=&quot;image-20240319160948462&quot; style=&quot;zoom:50%;&quot; /&gt; </span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   bool hasPathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">       // 如果根节点为空，则不存在满足条件的路径 , 就是一个路径都没有了。</span><br><span class="line">       if (!root) return false;</span><br><span class="line">       </span><br><span class="line">       // 如果当前节点是叶子节点，则判断当前节点值是否等于目标和</span><br><span class="line">       if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">           return targetSum == root-&gt;val;</span><br><span class="line">       &#125;</span><br><span class="line">       // 递归检查左子树和右子树</span><br><span class="line">       return hasPathSum(root-&gt;left, targetSum - root-&gt;val) ||  // 这就是向左走和向右走</span><br><span class="line">              hasPathSum(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="18-从中序与后序遍历序列构造二叉树"><a href="#18-从中序与后序遍历序列构造二叉树" class="headerlink" title="18. 从中序与后序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">18. 从中序与后序遍历序列构造二叉树</a></h2><h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h2><ul>
<li>对比 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/paths-with-sum-lcci/">面试题 04.12. 求和路径</a> （不要求从根节点开始）</li>
</ul>
<ol>
<li><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240319161840788.png" alt="image-20240319161840788" style="zoom:50%;" /> 
</li>
<li><pre><code class="cpp">void dfs(TreeNode* root, int targetSum, vector&lt;vector&lt;int&gt;&gt;&amp; result, vector&lt;int&gt;&amp; path) &#123;
    if (!root) return;
    
    // 将当前节点值添加到路径中
    path.push_back(root-&gt;val);
    
    // 如果当前节点是叶子节点，且路径和等于目标和，则将当前路径添加到结果中
    if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; targetSum == root-&gt;val) &#123;
        result.push_back(path);
    &#125;
    
    // 递归遍历左子树和右子树
    dfs(root-&gt;left, targetSum - root-&gt;val, result, path); // 从上一题的教训
    dfs(root-&gt;right, targetSum - root-&gt;val, result, path);
    
    // 回溯，将当前节点从路径中移除
    path.pop_back();
&#125;

vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    dfs(root, targetSum, result, path);
    return result;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)</span><br><span class="line"></span><br><span class="line">1. ```cpp</span><br><span class="line">       TreeNode* searchBST(TreeNode* root, int val) &#123; // 找到一个值或者根节点不存在，就返回root</span><br><span class="line">           if (!root ) return root;</span><br><span class="line">           if (root-&gt;val == val) return root;</span><br><span class="line">           else if (root-&gt;val &gt; val) return searchBST(root-&gt;left, val);</span><br><span class="line">           else &#123;</span><br><span class="line">               return searchBST(root-&gt;right, val);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li></li>
</ol>
<h2 id="23-验证二叉搜索树"><a href="#23-验证二叉搜索树" class="headerlink" title="23. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">23. 验证二叉搜索树</a></h2><ol>
<li><p>中序序列是一个<strong>生序序列</strong> </p>
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    vector&lt;int&gt; vec;
    void traversal(TreeNode* root) &#123;
        if (!root) return;
        traversal(root-&gt;left);
        vec.push_back(root-&gt;val);
        traversal(root-&gt;right);
    &#125;
    bool isValidBST(TreeNode* root) &#123;
        // 中序序列严格递增
        vec.clear(); // 清空一下
        traversal(root);
        for (int i = 1; i &lt; vec.size(); i++) &#123;
            if (vec[i] &lt;= vec[i - 1]) return false;
        &#125;
        return true;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [24. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)</span><br><span class="line"></span><br><span class="line">1. &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240319171556055.png&quot; alt=&quot;image-20240319171556055&quot; style=&quot;zoom:50%;&quot; /&gt; </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   ### 1. 直接转化为中序序列</span><br><span class="line"></span><br><span class="line">   1. ```cpp</span><br><span class="line">          void inorder(TreeNode* root, vector&lt;int&gt;&amp; res) &#123;</span><br><span class="line">              if (!root) return;</span><br><span class="line">              inorder(root-&gt;left, res);</span><br><span class="line">              res.push_back(root-&gt;val);</span><br><span class="line">              inorder(root-&gt;right, res);</span><br><span class="line">          &#125;</span><br><span class="line">          int getMinimumDifference(TreeNode* root) &#123;</span><br><span class="line">              // 一般做法</span><br><span class="line">              vector&lt;int&gt; res;</span><br><span class="line">              inorder(root, res);</span><br><span class="line">      </span><br><span class="line">              int minn = INT_MAX;</span><br><span class="line">              for (int i = 1; i &lt; res.size(); i++) &#123;</span><br><span class="line">                  minn = min(minn, res[i] - res[i - 1]);</span><br><span class="line">              &#125;</span><br><span class="line">              return minn;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h2><ol>
<li><pre><code class="cpp">    // 使用unordered_map
    // 先进行中序遍历
    void inorder(TreeNode* root, unordered_map&lt;int, int&gt;&amp; mapp) &#123;
        if (root == NULL) return;
        inorder(root-&gt;left, mapp);
        mapp[root-&gt;val] ++;
        inorder(root-&gt;right, mapp);
    &#125;

    vector&lt;int&gt; findMode(TreeNode* root) &#123;
     unordered_map&lt;int, int&gt; mapp; 
        inorder(root, mapp);

        // 找出现的最多的次数
        int maxFrequy = 0;
        for (const auto&amp; m : mapp) &#123;
            if (m.second &gt; maxFrequy) maxFrequy = m.second;
        &#125;
        vector&lt;int&gt; res;
        for (const auto&amp; m : mapp) &#123;
            if (m.second == maxFrequy) res.push_back(m.first);
        &#125;
        return res;
    &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)</span><br><span class="line"></span><br><span class="line">- &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240320151222927.png&quot; alt=&quot;image-20240320151222927&quot; style=&quot;zoom:50%;&quot; /&gt; </span><br><span class="line"></span><br><span class="line">1. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">           if (nums.empty()) &#123;</span><br><span class="line">               return nullptr;</span><br><span class="line">           &#125;</span><br><span class="line">           return sortedArrayToBST(nums, 0, nums.size() - 1);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   private:</span><br><span class="line">       TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums, int left, int right) &#123;</span><br><span class="line">           if (left &gt; right) &#123; // 不符合二叉搜索树</span><br><span class="line">               return nullptr;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           // 取中间元素作为根节点</span><br><span class="line">           int mid = left + (right - left) / 2;</span><br><span class="line">           TreeNode* root = new TreeNode(nums[mid]);</span><br><span class="line">           </span><br><span class="line">           // 递归构建左右子树</span><br><span class="line">           root-&gt;left = sortedArrayToBST(nums, left, mid - 1);</span><br><span class="line">           root-&gt;right = sortedArrayToBST(nums, mid + 1, right);</span><br><span class="line">           </span><br><span class="line">           return root;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h2><ol>
<li><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240320151731067.png" alt="image-20240320151731067" style="zoom:50%;" /> 
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    // 中序遍历吧
    vector&lt;int&gt; res;
    void traversal(TreeNode* root, vector&lt;int&gt;&amp; res) &#123;
        if (!root) return;
        traversal(root-&gt;left, res);
        res.push_back(root-&gt;val);
        traversal(root-&gt;right, res);
    &#125;
    int kthSmallest(TreeNode* root, int k) &#123;
        traversal(root, res);
        int i;
        for (i = 0; i &lt; k - 1; i++);
        return res[i];
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)</span><br><span class="line"></span><br><span class="line">1. &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240320153351992.png&quot; alt=&quot;image-20240320153351992&quot; style=&quot;zoom:50%;&quot; /&gt; </span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       // 寻找二叉搜索树中两个指定节点的最近公共祖先</span><br><span class="line">       TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* , TreeNode* q) &#123;</span><br><span class="line">           if (!root) return nullptr; // 如果根节点为空，则返回空指针</span><br><span class="line">   </span><br><span class="line">           int root_val = root-&gt;val; // 获取根节点的值</span><br><span class="line">           int p_val = p-&gt;val; // 获取第一个目标节点的值</span><br><span class="line">           int q_val = q-&gt;val; // 获取第二个目标节点的值</span><br><span class="line">   </span><br><span class="line">           // 如果两个目标节点的值都小于根节点的值，则最近公共祖先在左子树中</span><br><span class="line">           if (p_val &lt; root_val &amp;&amp; q_val &lt; root_val) &#123;</span><br><span class="line">               return lowestCommonAncestor(root-&gt;left, p, q); // 递归搜索左子树</span><br><span class="line">           &#125; </span><br><span class="line">           // 如果两个目标节点的值都大于根节点的值，则最近公共祖先在右子树中</span><br><span class="line">           else if (p_val &gt; root_val &amp;&amp; q_val &gt; root_val) &#123;</span><br><span class="line">               return lowestCommonAncestor(root-&gt;right, p, q); // 递归搜索右子树</span><br><span class="line">           &#125; </span><br><span class="line">           // 否则，当前节点就是最近公共祖先, 就是p和q分别在两边</span><br><span class="line">           else &#123;</span><br><span class="line">               return root;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><ol>
<li><pre><code class="cpp">    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
        // 如果根节点为空或者根节点等于p或q，则返回根节点
        if (!root || root == p || root == q) &#123;
            return root;
        &#125;
        
        // 在左子树中寻找p和q的最近公共祖先
        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);
        // 在右子树中寻找p和q的最近公共祖先
        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);
        
        // 如果左右子树都不为空，说明p和q分别在左右子树中，根节点即为最近公共祖先
        if (left &amp;&amp; right) &#123;
            return root;
        &#125;
        
        // 如果左子树为空，则说明p和q都在右子树中
        if (!left) &#123;
            return right;
        &#125;
        
        // 如果右子树为空，则说明p和q都在左子树中
        return left;
    &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## [508. 出现次数最多的子树元素和](https://leetcode.cn/problems/most-frequent-subtree-sum/)</span><br><span class="line"></span><br><span class="line">1. 给你一个二叉树的根结点 `root` ，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。</span><br><span class="line"></span><br><span class="line">   一个结点的 **「子树元素和」** 定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。</span><br><span class="line"></span><br><span class="line">2. &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240320155209077.png&quot; alt=&quot;image-20240320155209077&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">3. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       // 计算子树元素和</span><br><span class="line">       int subtreeSum(TreeNode* root, std::unordered_map&lt;int, int&gt;&amp; freq) &#123;</span><br><span class="line">           // 如果当前节点为空，则返回0</span><br><span class="line">           if (!root) &#123;</span><br><span class="line">               return 0;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           // 计算左子树的子树元素和</span><br><span class="line">           int left_sum = subtreeSum(root-&gt;left, freq);</span><br><span class="line">           // 计算右子树的子树元素和</span><br><span class="line">           int right_sum = subtreeSum(root-&gt;right, freq);</span><br><span class="line">           </span><br><span class="line">           // 计算以当前节点为根的子树元素和</span><br><span class="line">           int sum = root-&gt;val + left_sum + right_sum;</span><br><span class="line">           // 更新频率统计表</span><br><span class="line">           freq[sum]++;</span><br><span class="line">           </span><br><span class="line">           return sum;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       // 寻找出现次数最多的子树元素和</span><br><span class="line">       std::vector&lt;int&gt; findFrequentTreeSum(TreeNode* root) &#123;</span><br><span class="line">           std::unordered_map&lt;int, int&gt; freq; // 用于统计每个子树元素和的频率</span><br><span class="line">           std::vector&lt;int&gt; result; // 存储结果</span><br><span class="line">           </span><br><span class="line">           // 计算子树元素和</span><br><span class="line">           subtreeSum(root, freq);</span><br><span class="line">           </span><br><span class="line">           int max_freq = 0; // 最大频率</span><br><span class="line">           </span><br><span class="line">           // 找到最大频率</span><br><span class="line">           for (const auto&amp; entry : freq) &#123;</span><br><span class="line">               max_freq = std::max(max_freq, entry.second);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           // 将所有出现次数最多的子树元素和加入结果集</span><br><span class="line">           for (const auto&amp; entry : freq) &#123;</span><br><span class="line">               if (entry.second == max_freq) &#123;</span><br><span class="line">                   result.push_back(entry.first);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           return result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li></li>
</ol>
<h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h2><ol>
<li><p>远看是直径，实际上是，一个根节点的左子树和柚子树的最大深度的和；</p>
</li>
<li><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240320161919023.png" alt="image-20240320161919023" style="zoom:50%;" /> 
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    int diameterOfBinaryTree(TreeNode* root) &#123;
        int diameter = 0; // 存储最长路径的长度
        calculateDiameter(root, diameter); // 计算最长路径的长度
        return diameter; // 返回直径
    &#125;
    
    // 计算以当前节点为根的树的最大深度
    int calculateDepth(TreeNode* root) &#123;
        if (!root) &#123;
            return 0;
        &#125;
        int left_depth = calculateDepth(root-&gt;left);
        int right_depth = calculateDepth(root-&gt;right);
        return std::max(left_depth, right_depth) + 1;
    &#125;
    
    // 计算以当前节点为根的树的直径
    void calculateDiameter(TreeNode* root, int&amp; diameter) &#123;
        if (!root) &#123;
            return;
        &#125;
        
        // 计算左子树和右子树的深度
        int left_depth = calculateDepth(root-&gt;left);
        int right_depth = calculateDepth(root-&gt;right);
        
        // 更新最长路径的长度
        diameter = std::max(diameter, left_depth + right_depth);
        
        // 递归计算左子树和右子树的直径
        calculateDiameter(root-&gt;left, diameter);
        calculateDiameter(root-&gt;right, diameter);
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)</span><br><span class="line"></span><br><span class="line">1. 二叉树的**题目** ，主要就是，看成一个子树，节点啥的。</span><br><span class="line"></span><br><span class="line">2. &gt; 给你两棵二叉树： `root1` 和 `root2` 。</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; 返回合并后的二叉树。</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; **注意:** 合并过程必须从两个树的根节点开始。</span><br><span class="line"></span><br><span class="line">3. &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240320162547132.png&quot; alt=&quot;image-20240320162547132&quot; style=&quot;zoom:50%;&quot; /&gt; </span><br><span class="line"></span><br><span class="line">4. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">           // 如果其中一个树为空，则直接返回另一个树</span><br><span class="line">           if (!root1) return root2;</span><br><span class="line">           if (!root2) return root1;</span><br><span class="line">           </span><br><span class="line">           // 否则，将两棵树的节点值相加作为合并后节点的新值</span><br><span class="line">           root1-&gt;val += root2-&gt;val;</span><br><span class="line">           </span><br><span class="line">           // 递归合并左子树和右子树</span><br><span class="line">           root1-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);</span><br><span class="line">           root1-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);</span><br><span class="line">           </span><br><span class="line">           return root1;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="669-修剪二叉搜索树"><a href="#669-修剪二叉搜索树" class="headerlink" title="669. 修剪二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h2><ol>
<li><p><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240324122951233.png" alt="image-20240324122951233"> </p>
</li>
<li><pre><code class="cpp">    TreeNode* trimBST(TreeNode* root, int low, int high) &#123;
        // 如果根节点为空，则返回空
        if (!root) return nullptr;

        // 如果根节点的值小于 low，说明根节点及其左子树都不在修剪后的树中，递归修剪右子树，向右边走，找更大的。
        if (root-&gt;val &lt; low) return trimBST(root-&gt;right, low, high);
        
        // 如果根节点的值大于 high，说明根节点及其右子树都不在修剪后的树中，递归修剪左子树
        if (root-&gt;val &gt; high) return trimBST(root-&gt;left, low, high);
        
        // 如果根节点的值在 [low, high] 范围内，则修剪左右子树，并返回根节点
        // 就是更新修建过后的
        root-&gt;left = trimBST(root-&gt;left, low, high);
        root-&gt;right = trimBST(root-&gt;right, low, high);
        return root;
    &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 给定两个序列构建一棵树（拿下！）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)</span><br><span class="line"></span><br><span class="line">0. &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240324141006590.png&quot; alt=&quot;image-20240324141006590&quot; style=&quot;zoom:50%;&quot; /&gt; </span><br><span class="line"></span><br><span class="line">1. ```cpp</span><br><span class="line">       bool isSubtree(TreeNode* root, TreeNode* subRoot) &#123;</span><br><span class="line">           if (!root) return false; // 如果根节点为空，返回false</span><br><span class="line">           if (isSameTree(root, subRoot)) return true; // 如果当前根节点和子树根节点相同，返回true</span><br><span class="line">           // 否则递归地检查左子树和右子树</span><br><span class="line">           return isSubtree(root-&gt;left, subRoot) || isSubtree(root-&gt;right, subRoot);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       // 判断两棵树是否相同</span><br><span class="line">       bool isSameTree(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">           if (!root1 &amp;&amp; !root2) return true; // 如果两个根节点都为空，返回true</span><br><span class="line">           if (!root1 || !root2) return false; // 如果其中一个根节点为空，返回false</span><br><span class="line">           if (root1-&gt;val != root2-&gt;val) return false; // 如果根节点的值不相同，返回false</span><br><span class="line">           // 递归判断左子树和右子树是否相同</span><br><span class="line">           return isSameTree(root1-&gt;left, root2-&gt;left) &amp;&amp; isSameTree(root1-&gt;right, root2-&gt;right);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="513-找树左下角的值"><a href="#513-找树左下角的值" class="headerlink" title="513. 找树左下角的值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></h2><ol>
<li><p><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240324142857787.png" alt="image-20240324142857787"> </p>
</li>
<li><pre><code class="cpp">    int findBottomLeftValue(TreeNode* root) &#123;
        vector&lt;vector&lt;int&gt;&gt; reslut;
        queue&lt;TreeNode*&gt; que;
        if (root != NULL) que.push(root);

        while (!que.empty()) &#123;
            int size = que.size();
            vector&lt;int&gt; vec;

            for (int i = 0; i &lt; size; i++) &#123;
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node-&gt;val);
                if (node-&gt;left) que.push(node-&gt;left);
                if (node-&gt;right) que.push(node-&gt;right);
            &#125;
            reslut.push_back(vec);
        &#125;
        return reslut.back().front();
    &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)</span><br><span class="line"></span><br><span class="line">1. 给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。</span><br><span class="line"></span><br><span class="line">2. &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240324144522123.png&quot; alt=&quot;image-20240324144522123&quot; style=&quot;zoom:50%;&quot; /&gt; </span><br><span class="line"></span><br><span class="line">3. ```cpp</span><br><span class="line">       // 用于递归转换为累加树的辅助函数</span><br><span class="line">       void convertBSTHelper(TreeNode* root, int&amp; sum) &#123;</span><br><span class="line">           if (root == nullptr) return;</span><br><span class="line">   </span><br><span class="line">           // 遍历右子树</span><br><span class="line">           convertBSTHelper(root-&gt;right, sum);</span><br><span class="line">   </span><br><span class="line">           // 更新节点值为累加和</span><br><span class="line">           sum += root-&gt;val;</span><br><span class="line">           root-&gt;val = sum;</span><br><span class="line">   </span><br><span class="line">           // 遍历左子树</span><br><span class="line">           convertBSTHelper(root-&gt;left, sum);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       // 主函数，转换为累加树</span><br><span class="line">       TreeNode* convertBST(TreeNode* root) &#123;</span><br><span class="line">           int sum = 0;</span><br><span class="line">           convertBSTHelper(root, sum);</span><br><span class="line">           return root;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><blockquote>
<ol>
<li><code>convertBSTHelper(root-&gt;right, sum);</code>：首先递归遍历右子树。因为二叉搜索树中，右子树的节点值都大于等于根节点的值，所以先处理右子树可以确保每个节点的值都是累加和的一部分。</li>
<li><code>sum += root-&gt;val;</code>：在遍历右子树之后，累加当前节点的值到 <code>sum</code> 中。这样做是为了将右子树中所有节点的值累加到 <code>sum</code> 中，从而确保当前节点的值为当前节点及其右子树节点值的和。</li>
<li><code>root-&gt;val = sum;</code>：更新当前节点的值为累加和。因为 <code>sum</code> 包含了当前节点及其右子树节点的值之和，所以将 <code>sum</code> 的值赋给当前节点，从而完成了累加树的转换。</li>
<li><code>convertBSTHelper(root-&gt;left, sum);</code>：最后递归遍历左子树。由于当前节点的值已经更新为其原值加上右子树节点值的累加和，所以再遍历左子树时，左子树节点的值也会受到右子树节点值的影响，从而确保了整棵树的累加和的正确性。</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><ol>
<li>构造树一般采用的是前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。</li>
</ol>
<h2 id="1379-找出克隆二叉树中的相同节点"><a href="#1379-找出克隆二叉树中的相同节点" class="headerlink" title="1379. 找出克隆二叉树中的相同节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/">1379. 找出克隆二叉树中的相同节点</a></h2><ol>
<li><p>对于理解内存</p>
</li>
<li><p>my错误代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* original, TreeNode* cloned, TreeNode* target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!original) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (original == target &amp;&amp; cloned == target) &#123;</span><br><span class="line">            res = target;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">traversal</span>(original-&gt;left, cloned-&gt;left, target); </span><br><span class="line">        <span class="built_in">traversal</span>(original-&gt;right, cloned-&gt;right, target); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">getTargetCopy</span><span class="params">(TreeNode* original, TreeNode* cloned, TreeNode* target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(original, cloned, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><pre><code class="cpp">class Solution &#123;
private:
    TreeNode* res;
    void traversal(TreeNode* original, TreeNode* cloned, TreeNode* target) &#123;
        if (!original || res) return; // 加入res不为空的判断条件,就是res已经有结果了
        if (original == target) &#123; // 和原始的相同，返回，cloned
            res = cloned; // 更新结果为克隆树中对应的节点
            return;
        &#125;
        traversal(original-&gt;left, cloned-&gt;left, target); 
        traversal(original-&gt;right, cloned-&gt;right, target); 
    &#125;
public:
    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) &#123;
        traversal(original, cloned, target);
        return res;
    &#125;
&#125;;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. </span><br><span class="line"></span><br><span class="line">## [2331. 计算布尔二叉树的值](https://leetcode.cn/problems/evaluate-boolean-binary-tree/)</span><br><span class="line"></span><br><span class="line">1. ![image-20240401145035086](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401145035086.png)</span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       bool evaluateTree(TreeNode* root) &#123;</span><br><span class="line">           // 如果左子树为空，则根节点值必须为 1</span><br><span class="line">           if (root-&gt;left == nullptr) &#123;</span><br><span class="line">               return root-&gt;val == 1;</span><br><span class="line">           &#125;</span><br><span class="line">           // 如果根节点值为 2，则左右子树只要有一个为 true，整个表达式就为 true</span><br><span class="line">           if (root-&gt;val == 2) &#123;</span><br><span class="line">               return evaluateTree(root-&gt;left) || evaluateTree(root-&gt;right);</span><br><span class="line">           &#125;</span><br><span class="line">           // 如果根节点值为 0 或 1，则左右子树都必须为 true，整个表达式才为 true</span><br><span class="line">           // 也就是当前</span><br><span class="line">           return evaluateTree(root-&gt;left) &amp;&amp; evaluateTree(root-&gt;right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="897-递增顺序搜索树"><a href="#897-递增顺序搜索树" class="headerlink" title="897. 递增顺序搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/increasing-order-search-tree/">897. 递增顺序搜索树</a></h2><ol>
<li><p><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401172527338.png" alt="image-20240401172527338"></p>
</li>
<li><pre><code class="cpp">class Solution &#123;
private:
    // 中序遍历
    vector&lt;int&gt; vec;
    void traversal(TreeNode* root) &#123;
        if (!root) return;
        traversal(root-&gt;left);
        vec.push_back(root-&gt;val);
        traversal(root-&gt;right);
    &#125;
public:
    TreeNode* increasingBST(TreeNode* root) &#123;
        traversal(root);
        TreeNode* dummy = new TreeNode(-1); // 空节点用于返回
        TreeNode* res = new TreeNode(0);
        dummy-&gt;left = nullptr;
        dummy-&gt;right = res;

        for (int i = 0; i &lt; vec.size(); i++) &#123;
            res-&gt;val = vec[i];
            res-&gt;left = nullptr;
            if (i != vec.size() - 1) &#123;
                res-&gt;right = new TreeNode(0);
                res = res-&gt;right;
            &#125;
        &#125;
        return dummy-&gt;right;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 之后的解决方法</span><br><span class="line">   </span><br><span class="line">   ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   private:</span><br><span class="line">       std::vector&lt;TreeNode*&gt; vec;</span><br><span class="line">   </span><br><span class="line">       // 中序遍历，将节点存储在vec中</span><br><span class="line">       void traversal(TreeNode* root) &#123;</span><br><span class="line">           if (!root) return;</span><br><span class="line">           traversal(root-&gt;left);</span><br><span class="line">           vec.push_back(root);</span><br><span class="line">           traversal(root-&gt;right);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">   public:</span><br><span class="line">       TreeNode* increasingBST(TreeNode* root) &#123;</span><br><span class="line">           traversal(root); // 中序遍历二叉树，将节点存储在vec中</span><br><span class="line">           TreeNode* dummy = new TreeNode(-1);</span><br><span class="line">           TreeNode* pre = dummy;</span><br><span class="line">           for (auto it : vec) &#123;</span><br><span class="line">               it-&gt;left = nullptr; // 将左子树置空</span><br><span class="line">               pre-&gt;right = it; // 更新前一个节点的右子树为当前节点</span><br><span class="line">               pre = it; // 更新前一个节点</span><br><span class="line">           &#125;</span><br><span class="line">           return dummy-&gt;right; // 返回dummy节点的右子树，即新的根节点</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li><p><strong>关键是最后一步需要特殊处理一下</strong> </p>
<img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401172629178.png" alt="image-20240401172629178" style="zoom:50%;" /></li>
</ol>
<h2 id="1022-从根到叶的二进制数之和"><a href="#1022-从根到叶的二进制数之和" class="headerlink" title="1022. 从根到叶的二进制数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/">1022. 从根到叶的二进制数之和</a></h2><ol>
<li><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401174200293.png" alt="image-20240401174200293" style="zoom:50%;" />
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    void sumRootToLeafHelper(TreeNode* root, vector&lt;int&gt; path, vector&lt;vector&lt;int&gt;&gt;&amp; reslut) &#123;
        if (!root) return;
        // 
        path.push_back(root-&gt;val);
        if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;
            reslut.push_back(path);
        &#125;
        sumRootToLeafHelper(root-&gt;left, path, reslut);
        sumRootToLeafHelper(root-&gt;right, path, reslut);
    &#125;
    // 给一个二进制数组，求表示的实际的数
    int getVal(vector&lt;int&gt; vec) &#123;
        int sum = 0;
        for (int i = 0; i &lt; vec.size(); i++) &#123;
            if (vec[i]) sum += 1 &lt;&lt; (vec.size() - 1 - i);
        &#125;
        return sum;
    &#125;
    int sumRootToLeaf(TreeNode* root) &#123;
        vector&lt;int&gt; path;
        vector&lt;vector&lt;int&gt;&gt; reslut;
        sumRootToLeafHelper(root, path, reslut);

        long long int ans = 0;
        for (auto it : reslut) &#123;
            ans += getVal(it);
        &#125;
        return ans;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## [653. 两数之和 IV - 输入二叉搜索树](https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/)</span><br><span class="line"></span><br><span class="line">1. 给定一个二叉搜索树 `root` 和一个目标结果 `k`，如果二叉搜索树中存在两个元素且它们的和等于给定的目标结果，则返回 `true`</span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   private:</span><br><span class="line">       vector&lt;int&gt; vec;</span><br><span class="line">       // 求得中序遍历序列</span><br><span class="line">       void traversal(TreeNode* root) &#123;</span><br><span class="line">           if (!root) return;</span><br><span class="line">           traversal(root-&gt;left);</span><br><span class="line">           vec.push_back(root-&gt;val);</span><br><span class="line">           traversal(root-&gt;right);</span><br><span class="line">       &#125;</span><br><span class="line">       bool hasSum(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">           unordered_set&lt;int&gt; seen;</span><br><span class="line">           for (int num : nums) &#123;</span><br><span class="line">               int complement = k - num;</span><br><span class="line">               if (seen.count(complement)) &#123;</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">               seen.insert(num); // 否则就把当前数加入到set</span><br><span class="line">           &#125;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">   public:</span><br><span class="line">       bool findTarget(TreeNode* root, int k) &#123;</span><br><span class="line">           traversal(root);</span><br><span class="line">           return hasSum(vec, k);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li></li>
</ol>
<h2 id="872-叶子相似的树"><a href="#872-叶子相似的树" class="headerlink" title="872. 叶子相似的树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/leaf-similar-trees/">872. 叶子相似的树</a></h2><ol>
<li><p><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401195255728.png" alt="image-20240401195255728"> </p>
</li>
<li><pre><code class="cpp">class Solution &#123;
private:
    vector&lt;int&gt; vec;
    // 叶子结点
    bool isLeaf(TreeNode* root) &#123;
        if (!root) return false;
        if (!root-&gt;left &amp;&amp; !root-&gt;right) return true;
        return false;
    &#125;
    // 前序遍历
    void traversal(TreeNode* root) &#123;
        if (!root) return;
        if (isLeaf(root)) vec.push_back(root-&gt;val);
        traversal(root-&gt;left);
        traversal(root-&gt;right);
    &#125;
public:
    bool leafSimilar(TreeNode* root1, TreeNode* root2) &#123;
        traversal(root1);
        vector&lt;int&gt; vec1 = vec; 
        vec.clear();
        traversal(root2);
        vector&lt;int&gt; vec2 = vec; 
        return vec1 == vec2;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [993. 二叉树的堂兄弟节点](https://leetcode.cn/problems/cousins-in-binary-tree/)</span><br><span class="line"></span><br><span class="line">1. 如果二叉树的两个节点深度相同，但 **父节点不同** ，则它们是一对*堂兄弟节点*。</span><br><span class="line"></span><br><span class="line">   我们给出了具有唯一值的二叉树的根节点 `root` ，以及树中两个不同节点的值 `x` 和 `y` 。</span><br><span class="line"></span><br><span class="line">   只有与值 `x` 和 `y` 对应的节点是堂兄弟节点时，才返回 `true` 。否则，返回 `false`。</span><br><span class="line"></span><br><span class="line">2. &lt;img src=&quot;https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240401202114496.png&quot; alt=&quot;image-20240401202114496&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">3. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       bool isCousins(TreeNode* root, int x, int y) &#123;</span><br><span class="line">           if (!root) return false;</span><br><span class="line">           </span><br><span class="line">           queue&lt;TreeNode*&gt; q;</span><br><span class="line">           q.push(root);</span><br><span class="line">           </span><br><span class="line">           while (!q.empty()) &#123;</span><br><span class="line">               int size = q.size();</span><br><span class="line">               bool foundX = false, foundY = false;</span><br><span class="line">               for (int i = 0; i &lt; size; ++i) &#123;</span><br><span class="line">                   TreeNode* node = q.front();</span><br><span class="line">                   q.pop();</span><br><span class="line">                   </span><br><span class="line">                   if (node-&gt;val == x) foundX = true;</span><br><span class="line">                   if (node-&gt;val == y) foundY = true;</span><br><span class="line">                   </span><br><span class="line">                   if (node-&gt;left &amp;&amp; node-&gt;right) &#123;</span><br><span class="line">                       if ((node-&gt;left-&gt;val == x &amp;&amp; node-&gt;right-&gt;val == y) ||</span><br><span class="line">                           (node-&gt;left-&gt;val == y &amp;&amp; node-&gt;right-&gt;val == x)) &#123;</span><br><span class="line">                           return false; // 如果 x 和 y 是兄弟节点，则返回 false</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   </span><br><span class="line">                   if (node-&gt;left) &#123;</span><br><span class="line">                       q.push(node-&gt;left);</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (node-&gt;right) &#123;</span><br><span class="line">                       q.push(node-&gt;right);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               </span><br><span class="line">               if (foundX &amp;&amp; foundY) &#123;</span><br><span class="line">                   return true; // 如果找到了 x 和 y，则返回 true</span><br><span class="line">               &#125; else if (foundX || foundY) &#123;</span><br><span class="line">                   return false; // 如果只找到了其中一个，则说明不是堂兄弟节点</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           return false; // 如果在遍历过程中没有找到 x 和 y，则返回 false</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h2><ul>
<li><p><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240404104321832.png" alt="image-20240404104321832"> </p>
</li>
<li><pre><code class="cpp"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)</span><br><span class="line"></span><br><span class="line">1. 给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:</span><br><span class="line"></span><br><span class="line">   1. 创建一个根节点，其值为 `nums` 中的最大值。</span><br><span class="line">   2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。</span><br><span class="line">   3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。</span><br><span class="line"></span><br><span class="line">   返回 *`nums` 构建的* ***最大二叉树\*** 。</span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       int findMaxIndex(vector&lt;int&gt;&amp; nums, int left, int right) &#123;</span><br><span class="line">           int maxIndex = left;</span><br><span class="line">           for (int i = left + 1; i &lt;= right; ++i) &#123;</span><br><span class="line">               if (nums[i] &gt; nums[maxIndex]) &#123;</span><br><span class="line">                   maxIndex = i;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return maxIndex;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       TreeNode* construct(vector&lt;int&gt;&amp; nums, int left, int right) &#123;</span><br><span class="line">           // left和right是下标，所以得小于</span><br><span class="line">           if (left &gt; right) return nullptr;</span><br><span class="line">           </span><br><span class="line">           int maxIndex = findMaxIndex(nums, left, right);</span><br><span class="line">           TreeNode* root = new TreeNode(nums[maxIndex]);</span><br><span class="line">           </span><br><span class="line">           root-&gt;left = construct(nums, left, maxIndex - 1);</span><br><span class="line">           root-&gt;right = construct(nums, maxIndex + 1, right);</span><br><span class="line">           </span><br><span class="line">           return root;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">           if (nums.empty()) return nullptr;</span><br><span class="line">           return construct(nums, 0, nums.size() - 1);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h2 id="1315-祖父节点值为偶数的节点和"><a href="#1315-祖父节点值为偶数的节点和" class="headerlink" title="1315. 祖父节点值为偶数的节点和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-nodes-with-even-valued-grandparent/">1315. 祖父节点值为偶数的节点和</a></h2><ul>
<li><p>d</p>
</li>
<li><pre><code class="cpp">class Solution &#123;
public:
    // 返回满足条件的所有节点值之和
    int sumEvenGrandparent(TreeNode* root) &#123;
        if (!root) return 0; // 如果根节点为空，则返回0
        return dfs(root, nullptr, nullptr); // 调用递归函数
    &#125;
    
    // 递归函数，检查节点的祖父节点是否为偶数，并累加满足条件的节点值
    int dfs(TreeNode* node, TreeNode* parent, TreeNode* grandparent) &#123;
        if (!node) return 0; // 如果节点为空，返回0
        
        int sum = 0; // 初始化累加和
        
        // 如果祖父节点存在且为偶数，则累加当前节点值
        if (grandparent &amp;&amp; grandparent-&gt;val % 2 == 0) &#123;
            sum += node-&gt;val;
        &#125;
        
        // 递归遍历左右子树，并累加满足条件的节点值
        sum += dfs(node-&gt;left, node, parent);
        sum += dfs(node-&gt;right, node, parent);
        
        return sum; // 返回当前子树中满足条件的节点值之和
    &#125;
&#125;;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## [LCP 67. 装饰树](https://leetcode.cn/problems/KnLfVT/)</span><br><span class="line"></span><br><span class="line">- ```cpp</span><br><span class="line">  class Solution &#123;</span><br><span class="line">  public:</span><br><span class="line">      // 返回新的插入节点</span><br><span class="line">      // TreeNode* insertNode(TreeNode* parent) &#123;</span><br><span class="line">      //     if (!parent) return nullptr;</span><br><span class="line">      //     TreeNode* newNode = new TreeNode(-1);</span><br><span class="line">      //     parent-&gt;left = newNode</span><br><span class="line">      // &#125;</span><br><span class="line">      void dfs(TreeNode* root) &#123;</span><br><span class="line">          if (!root) return;</span><br><span class="line">          if (root-&gt;left) &#123;</span><br><span class="line">              TreeNode* newNode = new TreeNode(-1);</span><br><span class="line">              TreeNode* tmp1 = root-&gt;left;</span><br><span class="line">              root-&gt;left = newNode;</span><br><span class="line">              newNode-&gt;left = tmp1;</span><br><span class="line">              dfs(newNode-&gt;left);</span><br><span class="line">          &#125;</span><br><span class="line">          // -----right</span><br><span class="line">          if (root-&gt;right) &#123;</span><br><span class="line">              TreeNode* newNode = new TreeNode(-1);</span><br><span class="line">              TreeNode* tmp2 = root-&gt;right;</span><br><span class="line">              root-&gt;right = newNode;</span><br><span class="line">              newNode-&gt;right = tmp2;</span><br><span class="line">              dfs(newNode-&gt;right); // 这里不是root-&gt;right</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      TreeNode* expandBinaryTree(TreeNode* root) &#123;</span><br><span class="line">          dfs(root);</span><br><span class="line">          return root;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h2 id="305-两棵二叉搜索树中的所有元素"><a href="#305-两棵二叉搜索树中的所有元素" class="headerlink" title="305. 两棵二叉搜索树中的所有元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/">305. 两棵二叉搜索树中的所有元素</a></h2><ul>
<li><img src="https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240404152555628.png" alt="image-20240404152555628" style="zoom:50%;" /> 
</li>
<li><pre><code class="cpp">class Solution &#123;
private:
    vector&lt;int&gt; vec1, vec2;
    void traversal(TreeNode* root, vector&lt;int&gt;&amp; vec) &#123;
        if (!root) return;
        traversal(root-&gt;left, vec);
        vec.push_back(root-&gt;val);
        traversal(root-&gt;right, vec);
    &#125;
    vector&lt;int&gt; mergeVec(const vector&lt;int&gt;&amp; vec1, const vector&lt;int&gt;&amp; vec2) &#123;
        vector&lt;int&gt; res;
        int i = 0, j = 0;
        while (i &lt; vec1.size() &amp;&amp; j &lt; vec2.size()) &#123;
            if (vec1[i] &lt; vec2[j]) &#123;
                res.push_back(vec1[i++]);
            &#125; else &#123;
                res.push_back(vec2[j++]);
            &#125;
        &#125;
        while (i &lt; vec1.size()) &#123;
            res.push_back(vec1[i++]);
        &#125;
        while (j &lt; vec2.size()) &#123;
            res.push_back(vec2[j++]);
        &#125;
        return res;
    &#125;
public:
    vector&lt;int&gt; getAllElements(TreeNode* root1, TreeNode* root2) &#123;
        traversal(root1, vec1);
        traversal(root2, vec2);
        vector&lt;int&gt; res = mergeVec(vec1, vec2);
        return res;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [2415. 反转二叉树的奇数层](https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree/)</span><br><span class="line"></span><br><span class="line">- ```cpp</span><br><span class="line">  class Solution &#123;</span><br><span class="line">  public:</span><br><span class="line">      TreeNode* reverseOddLevels(TreeNode* root) &#123;</span><br><span class="line">          if (!root) return nullptr;</span><br><span class="line">  </span><br><span class="line">          queue&lt;TreeNode*&gt; que;</span><br><span class="line">          que.push(root);</span><br><span class="line">          int level = 0; // 从第一层开始</span><br><span class="line">          while (!que.empty()) &#123;</span><br><span class="line">              int size = que.size();</span><br><span class="line">              vector&lt;int&gt; vec1;</span><br><span class="line">              vector&lt;TreeNode*&gt; vec2;</span><br><span class="line">              for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">                  TreeNode* node = que.front();</span><br><span class="line">                  que.pop();</span><br><span class="line">                  vec1.push_back(node-&gt;val); // 将当前层的节点值存入 values 数组</span><br><span class="line">                  vec2.push_back(node);</span><br><span class="line">                  if (node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                  if (node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">              &#125;</span><br><span class="line">              if (level % 2 == 1) &#123;</span><br><span class="line">                  reverse(vec1.begin(), vec1.end());</span><br><span class="line">                  int index = 0; // 标记vec1</span><br><span class="line">                  for (auto node : vec2) &#123;</span><br><span class="line">                      node-&gt;val = vec1[index++];</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              level++;</span><br><span class="line">          &#125;</span><br><span class="line">          return root;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h2 id="1448-统计二叉树中好节点的数目"><a href="#1448-统计二叉树中好节点的数目" class="headerlink" title="1448. 统计二叉树中好节点的数目"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-good-nodes-in-binary-tree/">1448. 统计二叉树中好节点的数目</a></h2><ul>
<li><p>为什么这里函数curMax不用引用？</p>
<p>在这种情况下，我们不需要将curMax作为引用传递给dfs函数，因为我们不需要在dfs函数中修改调用者的curMax变量。在每次调用dfs函数时，我们都会传递一个新的curMax值，这个值是当前节点值和父节点的curMax值中较大的那个。在dfs函数内部，我们只需要使用这个新值来判断当前节点是否是好节点，并且在递归调用dfs函数时，将这个新值传递给下一层的子节点即可。</p>
<p>因此，我们不需要在dfs函数中修改调用者的curMax变量，也不需要通过引用传递来实现这个功能。相反，我们只需在每次调用dfs函数时传递一个新的curMax值，这样就可以正确地在整个二叉树上计算好节点的数量。</p>
</li>
</ul>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h2 id="408的24年真题"><a href="#408的24年真题" class="headerlink" title="408的24年真题"></a>408的24年真题</h2><ol>
<li><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

using namespace std;

// 有向图的表示
vector&lt;vector&lt;int&gt;&gt; adj;

// 计算每个节点的入度
vector&lt;int&gt; computeIndegree(int n) &#123;
    vector&lt;int&gt; indegree(n, 0);
    for (int i = 0; i &lt; n; ++i) &#123;
        for (int j : adj[i]) &#123;
            indegree[j]++;
        &#125;
    &#125;
    return indegree;
&#125;

// 拓扑排序
vector&lt;int&gt; topologicalSort(int n) &#123;
    vector&lt;int&gt; indegree = computeIndegree(n);
    vector&lt;int&gt; order;
    queue&lt;int&gt; q;

    // 将入度为0的节点加入队列
    for (int i = 0; i &lt; n; ++i) &#123;
        if (indegree[i] == 0) &#123;
            q.push(i);
        &#125;
    &#125;

    // 依次弹出入度为0的节点，并更新相关节点的入度
    while (!q.empty()) &#123;
        int node = q.front();
        q.pop();
        order.push_back(node);
        for (int neighbor : adj[node]) &#123;
            indegree[neighbor]--;
            if (indegree[neighbor] == 0) &#123;
                q.push(neighbor);
            &#125;
        &#125;
    &#125;

    // 如果有环，则返回空序列
    if (order.size() != n) &#123;
        return &#123;&#125;;
    &#125;
    return order;
&#125;

// 打印拓扑排序序列
void printTopologicalSort(int n) &#123;
    vector&lt;int&gt; order = topologicalSort(n);
    if (order.empty()) &#123;
        cout &lt;&lt; &quot;There is no unique topological order!&quot; &lt;&lt; endl;
    &#125; else &#123;
        cout &lt;&lt; &quot;Topological order(s):&quot; &lt;&lt; endl;
        do &#123;
            for (int node : order) &#123;
                cout &lt;&lt; node &lt;&lt; &quot; &quot;;
            &#125;
            cout &lt;&lt; endl;
        &#125; while (next_permutation(order.begin(), order.end()));
    &#125;
&#125;

int main() &#123;
    // 读取图的节点数和边数
    int n, m;
    cout &lt;&lt; &quot;Enter the number of nodes and edges: &quot;;
    cin &gt;&gt; n &gt;&gt; m;

    // 初始化邻接表
    adj.resize(n);

    // 读取边的信息
    cout &lt;&lt; &quot;Enter the edges (node_i node_j):&quot; &lt;&lt; endl;
    for (int i = 0; i &lt; m; ++i) &#123;
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        adj[u].push_back(v);
    &#125;

    // 输出拓扑排序序列
    printTopologicalSort(n);

    return 0;
&#125;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 已知图G采用邻接矩阵存储，试判断G是否有唯一的拓扑排序序列，如果有返回1否则返回0，使用cpp编程并给出注释，还要求给出G的结构体定义。</span><br><span class="line"></span><br><span class="line">   ```cpp</span><br><span class="line">   #include &lt;iostream&gt;</span><br><span class="line">   #include &lt;vector&gt;</span><br><span class="line">   </span><br><span class="line">   // 定义图的结构体</span><br><span class="line">   struct Graph &#123;</span><br><span class="line">       std::vector&lt;std::vector&lt;int&gt;&gt; adjMatrix; // 邻接矩阵存储图的边信息</span><br><span class="line">       int numVertices; // 图中顶点的数量</span><br><span class="line">   </span><br><span class="line">       // 构造函数</span><br><span class="line">       Graph(int n) : numVertices(n) &#123;</span><br><span class="line">           // 初始化邻接矩阵为全零</span><br><span class="line">           adjMatrix.resize(n, std::vector&lt;int&gt;(n, 0));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       // 拓扑排序函数</span><br><span class="line">       bool topologicalSort(Graph&amp; G) &#123;</span><br><span class="line">           std::vector&lt;int&gt; inDegree(G.numVertices, 0); // 存储每个顶点的入度</span><br><span class="line">           int count = 0; // 记录已经排序的顶点数量</span><br><span class="line">   </span><br><span class="line">           // 统计每个顶点的入度</span><br><span class="line">           for (int i = 0; i &lt; G.numVertices; ++i) &#123;</span><br><span class="line">               for (int j = 0; j &lt; G.numVertices; ++j) &#123;</span><br><span class="line">                   if (G.adjMatrix[i][j] == 1) &#123;</span><br><span class="line">                       inDegree[j]++;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           // 使用队列存储入度为0的顶点</span><br><span class="line">           std::vector&lt;int&gt; queue;</span><br><span class="line">           for (int i = 0; i &lt; G.numVertices; ++i) &#123;</span><br><span class="line">               if (inDegree[i] == 0) &#123;</span><br><span class="line">                   queue.push_back(i);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           // 开始拓扑排序</span><br><span class="line">           while (!queue.empty()) &#123;</span><br><span class="line">               int node = queue.front();</span><br><span class="line">               queue.erase(queue.begin());</span><br><span class="line">               ++count;</span><br><span class="line">   </span><br><span class="line">               // 更新与该顶点相邻的顶点的入度</span><br><span class="line">               for (int i = 0; i &lt; G.numVertices; ++i) &#123;</span><br><span class="line">                   if (G.adjMatrix[node][i] == 1) &#123;</span><br><span class="line">                       if (--inDegree[i] == 0) &#123;</span><br><span class="line">                           queue.push_back(i);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           // 如果拓扑排序后的顶点数量与图中的顶点数量相等，说明有唯一的拓扑排序序列</span><br><span class="line">           return count == G.numVertices;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   int main() &#123;</span><br><span class="line">       // 创建图的实例并初始化</span><br><span class="line">       Graph G(5); // 假设有5个顶点的图</span><br><span class="line">   </span><br><span class="line">       // 假设图的邻接矩阵如下所示（这里只展示了一种可能的情况，实际应用中需要根据具体情况填写邻接矩阵）</span><br><span class="line">       // 0 1 1 0 0</span><br><span class="line">       // 0 0 0 1 1</span><br><span class="line">       // 0 0 0 0 0</span><br><span class="line">       // 0 0 0 0 0</span><br><span class="line">       // 0 0 0 0 0</span><br><span class="line">       G.adjMatrix = &#123;&#123;0, 1, 1, 0, 0&#125;,</span><br><span class="line">                      &#123;0, 0, 0, 1, 1&#125;,</span><br><span class="line">                      &#123;0, 0, 0, 0, 0&#125;,</span><br><span class="line">                      &#123;0, 0, 0, 0, 0&#125;,</span><br><span class="line">                      &#123;0, 0, 0, 0, 0&#125;&#125;;</span><br><span class="line">   </span><br><span class="line">       // 创建Solution对象</span><br><span class="line">       Solution solution;</span><br><span class="line">       // 判断是否有唯一的拓扑排序序列</span><br><span class="line">       bool uniqueTopoSort = solution.topologicalSort(G);</span><br><span class="line">   </span><br><span class="line">       // 输出结果</span><br><span class="line">       std::cout &lt;&lt; &quot;The graph has a unique topological sorting sequence: &quot; &lt;&lt; uniqueTopoSort &lt;&lt; std::endl;</span><br><span class="line">   </span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title="785. 判断二分图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-graph-bipartite/">785. 判断二分图</a></h2><ol>
<li><pre><code class="cpp">class Solution &#123;
public:
    bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123;
        int n = graph.size();
        vector&lt;int&gt; colors(n, 0); // 记录每个节点的颜色，0 表示未染色，1 表示染成第一种颜色，-1 表示染成第二种颜色

        // 使用 BFS 遍历图
        for (int i = 0; i &lt; n; ++i) &#123;
            if (colors[i] != 0) continue; // 如果节点已经染色，跳过

            // BFS 遍历以 i 为起始节点的连通分量
            queue&lt;int&gt; q;
            q.push(i);
            colors[i] = 1; // 将起始节点染成第一种颜色

            while (!q.empty()) &#123;
                int node = q.front();
                q.pop();

                // 遍历当前节点的所有邻接节点
                for (int neighbor : graph[node]) &#123;
                    if (colors[neighbor] == 0) &#123; // 如果邻接节点未染色
                        colors[neighbor] = -colors[node]; // 将其染成与当前节点不同的颜色, 
                        q.push(neighbor); // 入队
                    &#125; else if (colors[neighbor] == colors[node]) &#123; // 如果邻接节点的颜色与当前节点相同，说明不是二分图
                        return false;
                    &#125;
                    // 如果邻接节点的颜色与当前节点不同，则继续遍历
                &#125;
            &#125;
        &#125;

        return true; // 如果能够完成染色，并且没有出现颜色冲突，则说明是二分图
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ` colors[neighbor] = -colors[node]; // 将其染成与当前节点不同的颜色, ` 不可以直接染成2，只要是不同就可以了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [207. 课程表](https://leetcode.cn/problems/course-schedule/)</span><br><span class="line"></span><br><span class="line">1. 深度优先遍历</span><br><span class="line"></span><br><span class="line">2. ```cpp</span><br><span class="line">   class Solution &#123;</span><br><span class="line">   public:</span><br><span class="line">       bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">           vector&lt;vector&lt;int&gt;&gt; adj(numCourses, vector&lt;int&gt;());</span><br><span class="line">           vector&lt;int&gt; inDegree(numCourses, 0);</span><br><span class="line">   </span><br><span class="line">           // 构建邻接表和入度数组</span><br><span class="line">           for (auto&amp; pre : prerequisites) &#123;</span><br><span class="line">               adj[pre[1]].push_back(pre[0]);</span><br><span class="line">               inDegree[pre[0]]++;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           // 将入度为 0 的节点加入队列</span><br><span class="line">           queue&lt;int&gt; q;</span><br><span class="line">           for (int i = 0; i &lt; numCourses; ++i) &#123;</span><br><span class="line">               if (inDegree[i] == 0) &#123;</span><br><span class="line">                   q.push(i);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           // 使用拓扑排序进行课程学习顺序的判断</span><br><span class="line">           while (!q.empty()) &#123;</span><br><span class="line">               int course = q.front(); // 当前的课程。neighbor,当前的课程可以到达的课程号。</span><br><span class="line">               q.pop();</span><br><span class="line">               numCourses--;</span><br><span class="line">   </span><br><span class="line">               for (int neighbor : adj[course]) &#123;</span><br><span class="line">                   if (--inDegree[neighbor] == 0) &#123; // 刚好有一个前置课程,这个边可以划去</span><br><span class="line">                       q.push(neighbor);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">   </span><br><span class="line">           return numCourses == 0;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a></h2><ul>
<li><p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code> 到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code> ，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程 <code>ai</code> 前 <strong>必须</strong> 先选修 <code>bi</code> 。</p>
<ul>
<li>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> ，我们用一个匹配来表示：<code>[0,1]</code> 。</li>
</ul>
<p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p>
</li>
</ul>
<ol>
<li><pre><code class="cpp">class Solution &#123;
public:
    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123;
        int n = numCourses;
        vector&lt;vector&lt;int&gt;&gt; adj(n, vector&lt;int&gt;());
        vector&lt;int&gt; inDegree(n);

        for (auto&amp; pre : prerequisites) &#123;
            adj[pre[1]].push_back(pre[0]);
            inDegree[pre[0]]++;
        &#125;

        queue&lt;int&gt; q;
        for (int i = 0; i &lt; n; i++) &#123;
            if (inDegree[i] == 0) &#123;
                q.push(i);
            &#125;
        &#125;

        // topsort（）
        vector&lt;int&gt; res;
        while (!q.empty()) &#123;
            int course = q.front();
            res.push_back(course);
            q.pop();

            for (auto neighbor : adj[course]) &#123;
                if (--inDegree[neighbor] == 0) &#123;
                    q.push(neighbor);
                &#125;
            &#125;
        &#125;
        for (int i = 0; i &lt; n; i++) &#123; // 一旦有入度不为0的，说明没有消去完全，不存在拓扑排序
            if (inDegree[i] != 0) &#123;
                return vector&lt;int&gt;();
            &#125;
        &#125;
        return res;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [LeetCode 1059. 从始点到终点的所有路径（回溯）](https://cloud.tencent.com/developer/article/1787958)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [684. 冗余连接](https://leetcode.cn/problems/redundant-connection/)</span><br><span class="line"></span><br><span class="line">- 树可以看成是一个连通且 **无环** 的 **无向** 图。</span><br><span class="line"></span><br><span class="line">  给定往一棵 `n` 个节点 (节点值 `1～n`) 的树中添加一条边后的图。添加的边的两个顶点包含在 `1` 到 `n` 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 `n` 的二维数组 `edges` ，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。</span><br><span class="line"></span><br><span class="line">  请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组 `edges` 中最后出现的那个。</span><br><span class="line"></span><br><span class="line">- ![image-20240403122535566](https://ybq-1325358415.cos.ap-nanjing.myqcloud.com/undefinedimage-20240403122535566.png) </span><br><span class="line"></span><br><span class="line">- ```cpp</span><br><span class="line">  class Solution &#123;</span><br><span class="line">  public:</span><br><span class="line">      // 找到节点所属的集合，使用路径压缩优化</span><br><span class="line">      int Find(vector&lt;int&gt;&amp; parent, int index) &#123;</span><br><span class="line">          // 如果节点的父节点不是自己，说明还没有找到根节点，继续向上找</span><br><span class="line">          if (parent[index] != index) &#123;</span><br><span class="line">              // 使用递归方式找到根节点，并将当前节点的父节点指向根节点</span><br><span class="line">              parent[index] = Find(parent, parent[index]);</span><br><span class="line">          &#125;</span><br><span class="line">          // 返回当前节点所属的根节点</span><br><span class="line">          return parent[index];</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      // 合并两个节点所属的集合，按秩合并</span><br><span class="line">      void Union(vector&lt;int&gt;&amp; parent, int index1, int index2) &#123;</span><br><span class="line">          // 找到两个节点所在的集合的根节点</span><br><span class="line">          int root1 = Find(parent, index1);</span><br><span class="line">          int root2 = Find(parent, index2);</span><br><span class="line">          // 将其中一个根节点指向另一个根节点，实现集合的合并</span><br><span class="line">          parent[root1] = root2;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      // 寻找多余的连接</span><br><span class="line">      vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;</span><br><span class="line">          int n = edges.size(); // 边的数量</span><br><span class="line">          vector&lt;int&gt; parent(n + 1); // 保存每个节点的父节点，初始时每个节点的父节点为自己</span><br><span class="line">          for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">              parent[i] = i; // 初始化每个节点的父节点为自己</span><br><span class="line">          &#125;</span><br><span class="line">          for (auto&amp; edge: edges) &#123; // 遍历每条边</span><br><span class="line">              int node1 = edge[0], node2 = edge[1]; // 获取边连接的两个节点</span><br><span class="line">              // 如果这两个节点不在同一个集合中，则合并这两个集合</span><br><span class="line">              if (Find(parent, node1) != Find(parent, node2)) &#123;</span><br><span class="line">                  Union(parent, node1, node2);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  // 如果这两个节点已经在同一个集合中，说明这条边是多余的，直接返回该边</span><br><span class="line">                  return edge;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          // 如果没有找到多余的连接，则返回空的vector</span><br><span class="line">          return vector&lt;int&gt;&#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<ul>
<li><pre><code class="cpp">class Solution &#123;
private:
    int p[1010];
    int find(int x) &#123;
        if (x != p[x]) &#123;
            p[x] = find(p[x]);
        &#125;
        return p[x];
    &#125;
        
public:
    vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;
        int n = edges.size();
        for (int i = 1; i &lt;= n; i++) &#123;
            p[i] = i;
        &#125;
        for (auto&amp; it : edges) &#123;
            int a = it[0];
            int b = it[1];
            if (find(a) != find(b)) &#123;
                p[find(a)] = find(b);
            &#125; else &#123;
                return it;
            &#125;
        &#125;
        return vector&lt;int&gt;();
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## [LCR 116. 省份数量](https://leetcode.cn/problems/bLyHh0/)</span><br><span class="line"></span><br><span class="line">- ```cpp</span><br><span class="line">  class Solution &#123;</span><br><span class="line">  private:</span><br><span class="line">          int find(vector&lt;int&gt;&amp; p, int x) &#123;</span><br><span class="line">              if (x != p[x]) &#123;</span><br><span class="line">                  p[x] = find(p, p[x]);</span><br><span class="line">              &#125;</span><br><span class="line">              return p[x];</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">  public:</span><br><span class="line">      int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) &#123;</span><br><span class="line">          int n = isConnected.size();</span><br><span class="line">          vector&lt;int&gt; p(n + 1); // 第一个空出来</span><br><span class="line">  </span><br><span class="line">          for (int i = 1; i &lt;= n; i++) p[i] = i;</span><br><span class="line">          // 只便利上半部分</span><br><span class="line">          for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">              for (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">                  if (isConnected[i][j] == 1) &#123;</span><br><span class="line">                      int a = i + 1;</span><br><span class="line">                      int b = j + 1;</span><br><span class="line">                      if (find(p, a) != find(p, b)) &#123;</span><br><span class="line">                          p[find(p, a)] = find(p, b);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          // 最后看p里面有几个不同的值</span><br><span class="line">          // unordered_set&lt;int&gt; set;</span><br><span class="line">          // for (int i = 1; i &lt;= n; i++) set.insert(p[i]);</span><br><span class="line">          // return set.size();</span><br><span class="line">          int count = 0;</span><br><span class="line">          for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">              if (p[i] == i) &#123; // 还是这个i号集合，所以可以</span><br><span class="line">                  count++;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          return count;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h2><ol>
<li><pre><code class="cpp">class Solution &#123;
public:
    const int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;
    int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y) &#123;
        if (x &lt; 0 || y &lt; 0 || x &gt;= grid.size() || y &gt;= grid[0].size() 
            || grid[x][y] == 0) &#123;
                return 0;
        &#125;
        int area = 1;
        grid[x][y] = 0;
        for (int k = 0; k &lt; 4; k++) &#123;
            int a = x + dx[k];
            int b = y + dy[k];
            area += dfs(grid, a, b);
        &#125;
        return area;
    &#125;
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;
        int ans = 0;
        int m = grid.size();
        int n = grid[0].size();
        for (int i = 0; i &lt; m; i++) &#123;
            for (int j = 0; j &lt; n; j++) &#123;
                ans = max(ans, dfs(grid, i, j));
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">2. 记忆化搜索</span><br><span class="line"></span><br><span class="line">   ```cpp</span><br><span class="line">   #include &lt;vector&gt;</span><br><span class="line">   #include &lt;algorithm&gt;</span><br><span class="line">   </span><br><span class="line">   using namespace std;</span><br><span class="line">   </span><br><span class="line">   class Solution &#123;</span><br><span class="line">   private:</span><br><span class="line">       int m, n;</span><br><span class="line">       vector&lt;vector&lt;int&gt;&gt; memo;</span><br><span class="line">   </span><br><span class="line">       int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j) &#123;</span><br><span class="line">           if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || grid[i][j] == 0 || memo[i][j] == 1) &#123;</span><br><span class="line">               return 0;</span><br><span class="line">           &#125;</span><br><span class="line">           memo[i][j] = 1; // 走过了</span><br><span class="line">           int area = 1;</span><br><span class="line">           area += dfs(grid, i + 1, j);</span><br><span class="line">           area += dfs(grid, i - 1, j);</span><br><span class="line">           area += dfs(grid, i, j + 1);</span><br><span class="line">           area += dfs(grid, i, j - 1);</span><br><span class="line">           return area;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">   public:</span><br><span class="line">       int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">           m = grid.size();</span><br><span class="line">           n = grid[0].size();</span><br><span class="line">           memo.assign(m, vector&lt;int&gt;(n, 0));</span><br><span class="line">           int maxArea = 0;</span><br><span class="line">           for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">               for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                   if (grid[i][j] == 1 &amp;&amp; memo[i][j] == 0) &#123;</span><br><span class="line">                       maxArea = max(maxArea, dfs(grid, i, j));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return maxArea;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h2 id="1267-统计参与通信的服务器"><a href="#1267-统计参与通信的服务器" class="headerlink" title="1267. 统计参与通信的服务器"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-servers-that-communicate/">1267. 统计参与通信的服务器</a></h2><ol>
<li><p>这里有一幅服务器分布图，服务器的位置标识在 <code>m * n</code> 的整数矩阵网格 <code>grid</code> 中，1 表示单元格上有服务器，0 表示没有。</p>
<p>如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。</p>
<p>请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。</p>
</li>
<li><p>总的 - 不能通信的（这一行一列就有一个服务器）</p>
</li>
</ol>
<ul>
<li><pre><code class="cpp">
class Solution &#123;
    public int countServers(int[][] grid) &#123;

        //先计算总共有多少服务器 allCount
        //再计算不能通信的服务器数量 badCount
        //能够通信的服务器goodCount=allCount-badCount

        //如果计算不能通信的服务器，某一行只有一个服务器并且该服务器对应的列也只有一台服务器




        int  allCount=0;
        int badCount=0;

        int pointA=0;

        //计算总共有多少服务器
        for(int i=0;i&lt;grid.length;i++)&#123;

            //行和
            int sumC=0;
            //列和
            int sumA=0;
            for(int j=0;j&lt;grid[i].length;j++)&#123;
                if(grid[i][j]==1)&#123;
                    allCount++;
                    sumC++;
                    //记录对应的列的下标
                    pointA=j;
                &#125;
            &#125;
            if(sumC==1)&#123;

                for(int k=0;k&lt;grid.length;k++)&#123;
                    //说明该行只有一个服务器
                    if(grid[k][pointA]==1)&#123;
                    sumA++;
                    &#125;
                &#125;
                if(sumA==1)&#123;
                    badCount++;
                &#125;
                
            &#125;

            

        &#125;

        return allCount-badCount;





    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)</span><br><span class="line"></span><br><span class="line">### 深度优先</span><br><span class="line"></span><br><span class="line">- ```cpp</span><br><span class="line">  class Solution &#123;</span><br><span class="line">  public:</span><br><span class="line">      int ans = 0;</span><br><span class="line">      int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">      void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; isvisited, int x, int y) &#123;</span><br><span class="line">          int n = grid.size(), m = grid[0].size();</span><br><span class="line">          if (x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= m || isvisited[x][y] || grid[x][y] == &#x27;0&#x27;) &#123;</span><br><span class="line">              return;</span><br><span class="line">          &#125;</span><br><span class="line">          isvisited[x][y] = true;</span><br><span class="line">          for (int k = 0; k &lt; 4; k++) &#123;</span><br><span class="line">              int nx = x + dx[k];</span><br><span class="line">              int ny = y + dy[k];</span><br><span class="line">              dfs(grid, isvisited, nx, ny);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; </span><br><span class="line">      int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123;</span><br><span class="line">          int n = grid.size(), m = grid[0].size();</span><br><span class="line">          vector&lt;vector&lt;bool&gt;&gt; isvisited(n, vector&lt;bool&gt;(m, false));</span><br><span class="line">          for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">              for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                  if (grid[i][j] == &#x27;1&#x27; &amp;&amp; !isvisited[i][j]) &#123;</span><br><span class="line">                      dfs(grid, isvisited, i, j);</span><br><span class="line">                      ans ++;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          return ans;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/04/05/111/" rel="prev" title="111">
      <i class="fa fa-chevron-left"></i> 111
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/04/05/222/" rel="next" title="222">
      222 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LCR-075-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.</span> <span class="nav-text">LCR 075. 数组的相对排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">2.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%E9%93%BE%E8%A1%A8demo"><span class="nav-number">2.1.</span> <span class="nav-text">自己写的链表demo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="nav-number">2.2.</span> <span class="nav-text">203. 移除链表元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">2.3.</span> <span class="nav-text">19. 删除链表的倒数第 N 个结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">2.4.</span> <span class="nav-text">83. 删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II"><span class="nav-number">2.5.</span> <span class="nav-text">82. 删除排序链表中的重复元素 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="nav-number">2.6.</span> <span class="nav-text">面试题 02.07. 链表相交</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9"><span class="nav-number">2.7.</span> <span class="nav-text">876. 链表的中间结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCR-024-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">2.8.</span> <span class="nav-text">LCR 024. 反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="nav-number">2.9.</span> <span class="nav-text">92. 反转链表 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">2.10.</span> <span class="nav-text">37. 删除链表中的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2181-%E5%90%88%E5%B9%B6%E9%9B%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">2.11.</span> <span class="nav-text">2181. 合并零之间的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="nav-number">2.12.</span> <span class="nav-text">114. 二叉树展开为链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#641-%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="nav-number">2.13.</span> <span class="nav-text">641. 设计循环双端队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="nav-number">2.14.</span> <span class="nav-text">143. 重排链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2816-%E7%BF%BB%E5%80%8D%E4%BB%A5%E9%93%BE%E8%A1%A8%E5%BD%A2%E5%BC%8F%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">2.15.</span> <span class="nav-text">2816. 翻倍以链表形式表示的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2487-%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%A7%BB%E9%99%A4%E8%8A%82%E7%82%B9"><span class="nav-number">2.16.</span> <span class="nav-text">2487. 从链表中移除节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#146-LRU-%E7%BC%93%E5%AD%98"><span class="nav-number">2.17.</span> <span class="nav-text">146. LRU 缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2058-%E6%89%BE%E5%87%BA%E4%B8%B4%E7%95%8C%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%B0%8F%E5%92%8C%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB"><span class="nav-number">2.18.</span> <span class="nav-text">2058. 找出临界点之间的最小和最大距离</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">3.1.</span> <span class="nav-text">前序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#445-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-II"><span class="nav-number">3.2.</span> <span class="nav-text">445. 两数相加 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="nav-number">3.3.</span> <span class="nav-text">100. 相同的树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-number">3.3.1.</span> <span class="nav-text">199. 二叉树的右视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#429-N-%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">3.3.2.</span> <span class="nav-text">429. N 叉树的层序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">3.3.3.</span> <span class="nav-text">104. 二叉树的最大深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="nav-number">3.3.4.</span> <span class="nav-text">111. 二叉树的最小深度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.4.</span> <span class="nav-text">226. 翻转二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.5.</span> <span class="nav-text">12.平衡二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="nav-number">3.6.</span> <span class="nav-text">404. 左叶子之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.7.</span> <span class="nav-text">18. 从中序与后序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II"><span class="nav-number">3.8.</span> <span class="nav-text">113. 路径总和 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">3.9.</span> <span class="nav-text">23. 验证二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="nav-number">3.10.</span> <span class="nav-text">501. 二叉搜索树中的众数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">3.11.</span> <span class="nav-text">230. 二叉搜索树中第K小的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">3.12.</span> <span class="nav-text">236. 二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-number">3.13.</span> <span class="nav-text">543. 二叉树的直径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">3.14.</span> <span class="nav-text">669. 修剪二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="nav-number">3.15.</span> <span class="nav-text">513. 找树左下角的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.16.</span> <span class="nav-text">最大二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1379-%E6%89%BE%E5%87%BA%E5%85%8B%E9%9A%86%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%90%8C%E8%8A%82%E7%82%B9"><span class="nav-number">3.17.</span> <span class="nav-text">1379. 找出克隆二叉树中的相同节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#897-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">3.18.</span> <span class="nav-text">897. 递增顺序搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1022-%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">3.19.</span> <span class="nav-text">1022. 从根到叶的二进制数之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#872-%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91"><span class="nav-number">3.20.</span> <span class="nav-text">872. 叶子相似的树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">3.21.</span> <span class="nav-text">96. 不同的二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1315-%E7%A5%96%E7%88%B6%E8%8A%82%E7%82%B9%E5%80%BC%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E8%8A%82%E7%82%B9%E5%92%8C"><span class="nav-number">3.22.</span> <span class="nav-text">1315. 祖父节点值为偶数的节点和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#305-%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0"><span class="nav-number">3.23.</span> <span class="nav-text">305. 两棵二叉搜索树中的所有元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1448-%E7%BB%9F%E8%AE%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A5%BD%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="nav-number">3.24.</span> <span class="nav-text">1448. 统计二叉树中好节点的数目</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">4.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">4.1.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#408%E7%9A%8424%E5%B9%B4%E7%9C%9F%E9%A2%98"><span class="nav-number">4.2.</span> <span class="nav-text">408的24年真题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#785-%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-number">4.3.</span> <span class="nav-text">785. 判断二分图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#210-%E8%AF%BE%E7%A8%8B%E8%A1%A8-II"><span class="nav-number">4.4.</span> <span class="nav-text">210. 课程表 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF"><span class="nav-number">4.5.</span> <span class="nav-text">695. 岛屿的最大面积</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1267-%E7%BB%9F%E8%AE%A1%E5%8F%82%E4%B8%8E%E9%80%9A%E4%BF%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">4.6.</span> <span class="nav-text">1267. 统计参与通信的服务器</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
